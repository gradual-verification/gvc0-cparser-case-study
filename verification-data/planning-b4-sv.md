- want to verify memory safety to avoid null pointer dereferences and infinite loops
- infinite loop can come about due to a cyclic token list input (and accidental modification of this list to be cyclic) and from creating and analyzing a AST with cycles
- null pointers can come about from assumptions about things being non-null but not being careful to ensure that or just regular bugs
- infinite loop was found in main due to a missing assignment in a dependency (tok list wasn't progressing)
- null pointer found in add_type due to simple case impl error, add_type goes over sub trees recursively so pretty important to make sure it's working okay
- want to statically verify paths not executed by test cases
- not going to verify test code; stringlist code (tested well with normal testing, similar to other verification efforts done in the past)
- while loops like in parser that goes until tok is EOF, parse_typedef which is looking for semicolon, and while loops in pointers, func_params, declspec, declaration, compound_stmt, funcall, postfix, mul, add, shift, relational, equality, bitand, bitxor, bitor, logand, logor, all loop until reaching some token representing certain program syntax in C like EOF, semicolon, until not seeing a * or | etc. token. Could functionally ensure token list contains EOF or is built correct to not loop forever in these cases, but that's a lot of replication of existing parser code. Easier to just prove and ensure acyclic of token list: the loop will always loop over the next token that is separated in memory from the previous one and since memory is finite eventually the loop will terminate.
- for loops like in find_var, add_type, find_tag, while loop in tagscopemap_put, varscopemap_put, and get versions, and add_type loop until the list is null/empty whether it be the scope list or ast node list, which means ensuring acyclicness of these things is important for avoiding infinite loops as well as ensuring the list is progressing
- so many loops also make it hard to pin-point where the infinite loop may be occurring at run time
- add_type recursively and iteratively goes through a sub AST of the program to add types to it and dereferencing multiple fields of the nodes and their tokens/types to do this, so null pointer dereferences can easily happen here when there are bugs; happened to find this after a while with testing; worth verifying this with IDF which is good for this
- difficult to manually create a lot of variants of logor, bitand, etc. in combo, so even though some of these paths are tested individually it would be good to verify them
- start with making sure input token list is the right shape and progresses with the right shape then add in AST result guarantees + add_type (can do this gradually) - can check null-pointer dereferences as I go
