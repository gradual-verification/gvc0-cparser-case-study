/* Feature list
  - local vars declarations only

   Types
   - int (and a bunch of built in integer types)
   - char
   - bool
   - struct types --- going to add support for this last in the core since it has doable but interesting complexity; FEATURE EXTENSION MAYBE?
   - numeric literals have their string contents saved in nodes rather than contains ints or longs with content since C0 doesn't support anything but ints
   
   Not doing + why:
   - Arrays - implementation similar to structs but a bit more complexity
   - Unions - implementation similar to structs
   - global vars - more complexity, look into this
   - casts + pointer arithmentic - advanced C features
   - variadic functions - advanced C feature
   - no variable-length array - advanced feature; no arrays

   - explanation could be following the C0 -> c1 -> educational path but I'm not sure C0 supports too much more like enums, switches, etc.

   - Types -- most type removal is just repetitative code for dealing with them compared to ones that I am implementing
      - _Alignas - advanced c feature, since c11
      - union - for obvious reasons
      - __restrict, __restrict__ - these are same as restrict (keeping) just for C++
      - "_Noreturn" - advanced c feature since c23; deprecated for another syntax
      - _Thread_local, __thread - advanced c feature since c11; __thread was predecessor to c11 _Thread_local
      - _Atomic - advanced c feature for threads; since c11
      - typeof - compiler extension, not in base c, advanced feature no-the-less
   - Functions can't have
      - array arguments
      - function arguments
      - __func__ not allowed as local variable in function - advanced feature
        - __FUNCTION__ either
      - asm statements -- no assembly stmts allowed, too complex
      - builtin alloca -- must be builtin and is machine and compiler-dependent; allocating from the stack
        - no builtins
   - compare and swap for atomics, atomic operators 
   - Not doing to slim up functionality (getting a little bit large)
    - gotos
    - switches
    - do while loops
    - for loops
    - break, continue
    - labeled statements
    - static, extern, inline types
    - labels-as-values
    - initializers
    - conditionals
    - _Generic
    - __builtin_types_compatible_p
    - __builtin_reg_class
    - _Alignof
    - GNU statement expressions - advanced feature
    - sizeof
    - A++, A-- (--A, ++A also not supported)
    - enums
    - string_lits
    - parameter types of functions and their caller args must match (no implicit casts)
    - | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^="
      | "<<=" | ">>="
    - assignment has to come after declaration, can have multiple decls separated by commas
   
   
   Decls
   - function  


   Statements
   - alloc
   - free
   - struct -- will do as a feature extension
   - function call
   - pointer assignment
   - variable assignment
   - type decl
   - ifs
   - loops

*/

#use <conio>

//------------StringList--------------------------------------------------------------------------------
/* Public Interface */
typedef struct StringList StringList;

StringList *new_stringlist();
void add_char(StringList *s, char c);
bool equals(StringList *s1, StringList *s2);
int get_len(StringList *s);

/* Private Implementation */
typedef struct CharNode CharNode;
struct CharNode {
  char val;
  CharNode *next;
};

struct StringList {
  CharNode *root;
  int len;
};

// Create a new empty string in list form
StringList *new_stringlist() {
  StringList *s = alloc(struct StringList);
  CharNode *r = alloc(struct CharNode);
  r->val = '\0';
  r->next = NULL;
  s->root = r;
  s->len = 0;
  return s;
}

// Add char to the end of the string
void add_char(StringList *s, char c) {
  if (s == NULL) {
    error("Adding char to string list that's NULL");
  } else if (s->root == NULL) {
    CharNode *end = alloc(struct CharNode);
    end->val = '\0';
    end->next = NULL;
    CharNode *cnode = alloc(struct CharNode);
    cnode->val = c;
    cnode->next = end;
    s->root = cnode;
    s->len = 1;
  } else if (s->root->next == NULL) {
    CharNode *cnode = alloc(struct CharNode);
    cnode->val = c;
    cnode->next = s->root;
    s->root = cnode;
    s->len = 1;
  } else {
      CharNode *prev = s->root;
      CharNode *r = s->root;
      while (r->next != NULL) {
        prev = r;
        r = r->next;
      }
      CharNode *cnode = alloc(struct CharNode);
      cnode->val = c;
      cnode->next = r;
      prev->next = cnode;
      s->len = s->len + 1;
  }
}

// Tests whether the two string lists are equal (have the exact same contents, including same len)
bool equals(StringList *s1, StringList *s2) {
  if (s1 != NULL && 
      s2 != NULL && 
      s1->root != NULL &&
      s2->root != NULL &&
      s1->len == s2->len) {
    int ln = s2->len;
    int i;
    CharNode *c1 = s1->root;
    CharNode *c2 = s2->root;
    bool eq = true;
    for (i = 0; i < ln; i = i + 1) {
      eq = eq && c1->val == c2->val;
      c1 = c1->next;
      c2 = c2->next;
    }
    eq = eq && c1->val == '\0' && c2->val == '\0';
    return eq;
  }
  return false;
}

int get_len(StringList *s) {
  return s != NULL ? s->len : -1;
}

//-------------Token-----------------------------------------------------------------------------------
// Input tokens are represented by a linked list. Unlike many recursive
// descent parsers, we don't have the notion of the "input token stream".
// Most parsing functions don't change the global state of the parser.
// So it is very easy to lookahead arbitrary number of tokens in this
// parser.

typedef struct Type Type;

/* Public Interface */
typedef struct Token Token; // remove more as I narrow down the feature set from going top down
typedef struct TokenKind TokenKind;

struct Token {
  TokenKind *kind;         // Token kind
  Token *next;      // Next token
  //int64_t val;      // If kind is TK_NUM, its value
  //long double fval; // If kind is TK_NUM, its value
  //char *loc;        // Token location
  //int len;          // Token length
  Type *ty;         // Used if TK_NUM or TK_STR
  StringList *str;    // String literal contents including terminating '\0' and token len
};

// Checks if a token is of the specified kind
bool is_IDENT(Token *t);
bool is_PUNCT(Token *t);
bool is_KEYWORD(Token *t);
bool is_STR(Token *t);
bool is_NUM(Token *t);
bool is_PP_NUM(Token *t);
bool is_EOF(Token *t);

// Creates a new tokenkind with the specified kind
TokenKind *new_TK_IDENT();
TokenKind *new_TK_PUNCT();
TokenKind *new_TK_KEYWORD();
TokenKind *new_TK_STR();
TokenKind *new_TK_NUM();
TokenKind *new_TK_PP_NUM();
TokenKind *new_TK_EOF();

// Helper functions for tokens
bool equal(Token *tok, StringList *op);
Token *skip(Token *tok, StringList *op);
bool consume(Token **rest, Token *tok, StringList *str);
Token *new_token(TokenKind *kind, StringList *str);
StringList *name(Token *tok);

/* Private Implementation */
struct TokenKind {
  int kind;
};

bool is_IDENT(Token *t) {
  if (t != NULL && t->kind != NULL)
    return t->kind->kind == 1;
  else
    return false; 
}
bool is_PUNCT(Token *t) {
  if (t != NULL && t->kind != NULL)
    return t->kind->kind == 2;
  else
    return false;
}
bool is_KEYWORD(Token *t) {
  if (t != NULL && t->kind != NULL)
    return t->kind->kind == 3;
  else
    return false;
}
bool is_STR(Token *t) {
  if (t != NULL && t->kind != NULL)
    return t->kind->kind == 4;
  else
    return false;
}
bool is_NUM(Token *t) {
  if (t != NULL && t->kind != NULL)
    return t->kind->kind == 5;
  else
    return false;
}
bool is_PP_NUM(Token *t) {
  if (t != NULL && t->kind != NULL)
    return t->kind->kind == 6;
  else
    return false;
}
bool is_EOF(Token *t) {
  if (t != NULL && t->kind != NULL)
    return t->kind->kind == 7;
  else
    return false;
}

TokenKind *new_TK_IDENT() {
  TokenKind *tk = alloc(struct TokenKind);
  tk->kind = 1;
  return tk;  
}
TokenKind *new_TK_PUNCT() {
  TokenKind *tk = alloc(struct TokenKind);
  tk->kind = 2;
  return tk;  
}
TokenKind *new_TK_KEYWORD() {
  TokenKind *tk = alloc(struct TokenKind);
  tk->kind = 3;
  return tk;  
}
TokenKind *new_TK_STR() {
  TokenKind *tk = alloc(struct TokenKind);
  tk->kind = 4;
  return tk;  
}
TokenKind *new_TK_NUM() {
  TokenKind *tk = alloc(struct TokenKind);
  tk->kind = 5;
  return tk; 
}
TokenKind *new_TK_PP_NUM() {
  TokenKind *tk = alloc(struct TokenKind);
  tk->kind = 6;
  return tk;
}
TokenKind *new_TK_EOF() {
  TokenKind *tk = alloc(struct TokenKind);
  tk->kind = 7;
  return tk;
}

// Create a new token.
Token *new_token(TokenKind *kind, StringList *contents) {
  Token *tok = alloc(struct Token);
  tok->kind = kind;
  tok->str = contents;
  return tok;
}

// Ensure that the current token is `op`.
bool equal(Token *tok, StringList *op) {
  return equals(tok->str, op);
}

// Skips the current token if it matches `op`.
Token *skip(Token *tok, StringList *op) {
  if (!equal(tok, op))
    error("Token does not match expected op");
  return tok->next;
}

// Consumes the current token if it matches `op`.
bool consume(Token **rest, Token *tok, StringList *str) {
  if (equal(tok, str)) {
    *rest = tok->next;
    return true;
  }
  *rest = tok;
  return false;
}

StringList *name(Token *tok) {
  if (tok == NULL) {
    return NULL;
  } else {
    return tok->str;
  }
}

//--------------Type---------------------------------------------------------------------------------------

/* Public Interface */
//typedef struct Type Type;
typedef struct TypeKind TypeKind;

struct Type {
  TypeKind *kind;
  int size;           // sizeof() value
  int align;          // alignment
  bool is_unsigned;   // unsigned or signed
  Type *origin;       // for type compatibility check

  // Pointer-to or array-of type. We intentionally use the same member
  // to represent pointer/array duality in C.
  //
  // In many contexts in which a pointer is expected, we examine this
  // member instead of "kind" member to determine whether a type is a
  // pointer or not. That means in many contexts "array of T" is
  // naturally handled as if it were "pointer to T", as required by
  // the C spec.
  Type *base;

  // Declaration
  Token *name;
  Token *name_pos;

  // Struct
  /*Member *members;
  bool is_flexible;
  bool is_packed;*/

  // Function type
  Type *return_ty;
  Type *params;
  Type *next;
};

// Checks if a type is of the specified kind
bool is_VOID(Type *ty);
bool is_BOOL(Type *ty);
bool is_CHAR(Type *ty);
bool is_SHORT(Type *ty);
bool is_INT(Type *ty);
bool is_LONG(Type *ty);
bool is_FLOAT(Type *ty);
bool is_DOUBLE(Type *ty);
bool is_LDOUBLE(Type *ty);
bool is_ENUM(Type *ty);
bool is_PTR(Type *ty);
bool is_FUNC(Type *ty);
bool is_STRUCT(Type *ty);

// Creates a new typekind with the specified kind
TypeKind *new_TY_VOID();
TypeKind *new_TY_BOOL();
TypeKind *new_TY_CHAR();
TypeKind *new_TY_SHORT();
TypeKind *new_TY_INT();
TypeKind *new_TY_LONG();
TypeKind *new_TY_FLOAT();
TypeKind *new_TY_DOUBLE();
TypeKind *new_TY_LDOUBLE();
TypeKind *new_TY_ENUM();
TypeKind *new_TY_PTR();
TypeKind *new_TY_FUNC();
TypeKind *new_TY_STRUCT();

// Helper functions for types
Type *new_type(TypeKind *kind, int size, int align);
Type *empty_type();

Type *new_ty_void();
Type *new_ty_bool();

Type *new_ty_char();
Type *new_ty_short();
Type *new_ty_int();
Type *new_ty_long();

Type *new_ty_uchar();
Type *new_ty_ushort();
Type *new_ty_uint();
Type *new_ty_ulong();

Type *new_ty_float();
Type *new_ty_double();
Type *new_ty_ldouble();

Type *enum_type();
Type *struct_type();
Type *func_type(Type *return_ty);
Type *pointer_to(Type *base);
Type *copy_type(Type *ty);
bool is_numeric(Type *ty);
bool same_typekind(Type *ty1, Type *ty2);

StringList *ty_name(Type* ty);

// Struct member
/*struct Member {
  Member *next;
  Type *ty;
  Token *tok; // for error message
  Token *name;
  int idx;
  int align;
  int offset;

  // Bitfield
  bool is_bitfield;
  int bit_offset;
  int bit_width;
};*/

/* Private Implementation */
struct TypeKind {
  int kind;
};

bool is_VOID(Type *ty) {
  if (ty != NULL && ty->kind != NULL)
    return ty->kind->kind == 1;
  else
    return false; 
}
bool is_BOOL(Type *ty) {
  if (ty != NULL && ty->kind != NULL)
    return ty->kind->kind == 2;
  else
    return false; 
}
bool is_CHAR(Type *ty) {
  if (ty != NULL && ty->kind != NULL)
    return ty->kind->kind == 3;
  else
    return false; 
}
bool is_SHORT(Type *ty) {
  if (ty != NULL && ty->kind != NULL)
    return ty->kind->kind == 4;
  else
    return false; 
}
bool is_INT(Type *ty) {
  if (ty != NULL && ty->kind != NULL)
    return ty->kind->kind == 5;
  else
    return false; 
}
bool is_LONG(Type *ty) {
  if (ty != NULL && ty->kind != NULL)
    return ty->kind->kind == 6;
  else
    return false; 
}
bool is_FLOAT(Type *ty) {
  if (ty != NULL && ty->kind != NULL)
    return ty->kind->kind == 7;
  else
    return false; 
}
bool is_DOUBLE(Type *ty) {
  if (ty != NULL && ty->kind != NULL)
    return ty->kind->kind == 8;
  else
    return false; 
}
bool is_LDOUBLE(Type *ty) {
  if (ty != NULL && ty->kind != NULL)
    return ty->kind->kind == 9;
  else
    return false; 
}
bool is_ENUM(Type *ty) {
  if (ty != NULL && ty->kind != NULL)
    return ty->kind->kind == 10;
  else
    return false; 
}
bool is_PTR(Type *ty) {
  if (ty != NULL && ty->kind != NULL)
    return ty->kind->kind == 11;
  else
    return false; 
}
bool is_FUNC(Type *ty) {
  if (ty != NULL && ty->kind != NULL)
    return ty->kind->kind == 12;
  else
    return false; 
}
bool is_STRUCT(Type *ty) {
  if (ty != NULL && ty->kind != NULL)
    return ty->kind->kind == 13;
  else
    return false; 
}

TypeKind *new_TY_VOID() {
  TypeKind *ty = alloc(struct TypeKind);
  ty->kind = 1;
  return ty;  
}
TypeKind *new_TY_BOOL() {
  TypeKind *ty = alloc(struct TypeKind);
  ty->kind = 2;
  return ty;  
}
TypeKind *new_TY_CHAR() {
  TypeKind *ty = alloc(struct TypeKind);
  ty->kind = 3;
  return ty;  
}
TypeKind *new_TY_SHORT() {
  TypeKind *ty = alloc(struct TypeKind);
  ty->kind = 4;
  return ty;  
}
TypeKind *new_TY_INT() {
  TypeKind *ty = alloc(struct TypeKind);
  ty->kind = 5;
  return ty;  
}
TypeKind *new_TY_LONG() {
  TypeKind *ty = alloc(struct TypeKind);
  ty->kind = 6;
  return ty;  
}
TypeKind *new_TY_FLOAT() {
  TypeKind *ty = alloc(struct TypeKind);
  ty->kind = 7;
  return ty;  
}
TypeKind *new_TY_DOUBLE() {
  TypeKind *ty = alloc(struct TypeKind);
  ty->kind = 8;
  return ty;  
}
TypeKind *new_TY_LDOUBLE() {
  TypeKind *ty = alloc(struct TypeKind);
  ty->kind = 9;
  return ty;  
}
TypeKind *new_TY_ENUM() {
  TypeKind *ty = alloc(struct TypeKind);
  ty->kind = 10;
  return ty;  
}
TypeKind *new_TY_PTR() {
  TypeKind *ty = alloc(struct TypeKind);
  ty->kind = 11;
  return ty;  
}
TypeKind *new_TY_FUNC() {
  TypeKind *ty = alloc(struct TypeKind);
  ty->kind = 12;
  return ty;  
}
TypeKind *new_TY_STRUCT() {
  TypeKind *ty = alloc(struct TypeKind);
  ty->kind = 13;
  return ty;  
}

bool same_typekind(Type *ty1, Type *ty2) {
  if (ty1 == NULL       || ty2 == NULL ||
      ty1->kind == NULL || ty2->kind == NULL
     )
  {
    return false;
  } else {
    return ty1->kind->kind == ty2->kind->kind;
  }
}

Type *new_type(TypeKind *kind, int size, int align) {
  Type *ty = alloc(struct Type);
  ty->kind = kind;
  ty->size = size;
  ty->align = align;
  return ty;
}
Type *empty_type() {
  Type *ty = alloc(struct Type);
  return ty;
}

Type *new_ty_void() {
  return new_type(new_TY_VOID(),1,1);
}
Type *new_ty_bool() {
  return new_type(new_TY_BOOL(),1,1);
}

Type *new_ty_char() {
  return new_type(new_TY_CHAR(),1,1);
}
Type *new_ty_short() {
  return new_type(new_TY_SHORT(),2,2);
}
Type *new_ty_int() {
  return new_type(new_TY_INT(),4,4);
}
Type *new_ty_long() {
  return new_type(new_TY_LONG(),8,8);
}

Type *new_ty_uchar() {
  Type *ty = new_type(new_TY_CHAR(),1,1);
  ty->is_unsigned = true;
  return ty;
}
Type *new_ty_ushort() {
  Type *ty = new_type(new_TY_SHORT(),2,2);
  ty->is_unsigned = true;
  return ty;
}
Type *new_ty_uint() {
  Type *ty = new_type(new_TY_INT(),4,4);
  ty->is_unsigned = true;
  return ty;
}
Type *new_ty_ulong() {
  Type *ty = new_type(new_TY_LONG(),8,8);
  ty->is_unsigned = true;
  return ty;
}

Type *new_ty_float() {
  return new_type(new_TY_FLOAT(),4,4);
}
Type *new_ty_double() {
  return new_type(new_TY_DOUBLE(),8,8);
}
Type *new_ty_ldouble() {
  return new_type(new_TY_LDOUBLE(),16,16);
}
Type *pointer_to(Type *base) {
  Type *ty = new_type(new_TY_PTR(), 8, 8);
  ty->base = base;
  ty->is_unsigned = true;
  return ty;
}

Type *enum_type() {
  return new_type(new_TY_ENUM(),4,4);
}
Type *struct_type() {
  return new_type(new_TY_STRUCT(),0,1);
}
Type *func_type(Type *return_ty) {
  // The C spec disallows sizeof(<function type>), but
  // GCC allows that and the expression is evaluated to 1.
  Type *ty = new_type(new_TY_FUNC(),1,1);
  ty->return_ty = return_ty;
  return ty;
}
Type *copy_type(Type *ty) {
  Type *ret = alloc(Type);
  ret->kind = ty->kind;
  ret->size = ty->size;
  ret->align = ty->align;
  ret->is_unsigned = ty->is_unsigned;
  ret->origin = ty;
  ret->base = ty->base;
  ret->name = ty->name;
  ret->name_pos = ty->name_pos;
  ret->return_ty = ty->return_ty;
  ret->params = ty->params;
  ret->next = ty->next;
  return ret;
}
bool is_numeric(Type *ty) {
  return is_INT(ty)   || is_BOOL(ty)   || is_CHAR(ty) ||
         is_SHORT(ty) || is_LONG(ty)   || is_ENUM(ty) ||
         is_FLOAT(ty) || is_DOUBLE(ty) || is_LDOUBLE(ty);
}

StringList *ty_name(Type *ty) {
  if (ty != NULL) {
    return name(ty->name);
  } else {
    return NULL;
  }
}

//-------------Object-----------------------------------------------------------------------------------

typedef struct ASTNode ASTNode;

/* Public Interface */

// Variable or function
typedef struct Obj Obj;
struct Obj {
  Obj *next;
  StringList *name;    // Variable name
  Type *ty;      // Type
  Token *tok;    // representative token
  bool is_local; // local or global/function
  int align;     // alignment

  // Local variable
  int offset;

  // Global variable or function
  bool is_function;
  bool is_definition;

  // Function
  Obj *params;
  ASTNode *body;
  Obj *locals;
  int stack_size;
};

/* Private Implementation */

//-------------ASTNode-------------------------------------------------------------------------------------

/* Public Interface */
typedef struct NodeKind NodeKind;
// typedef struct ASTNode ASTNode;

// AST node type
struct ASTNode {
  NodeKind *kind; // Node kind
  ASTNode *next;    // Next node
  Type *ty;      // Type, e.g. int or pointer to int
  Token *tok;    // Representative token

  ASTNode *lhs;     // Left-hand side
  ASTNode *rhs;     // Right-hand side

  // "if" or "for" statement
  ASTNode *cond;
  ASTNode *then;
  ASTNode *els;
  ASTNode *init;
  ASTNode *inc;

  // Block or statement expression
  ASTNode *body;

  // Struct member access
  //Member *member;

  // Function call
  Type *func_ty;
  ASTNode *args;
  bool pass_by_stack;
  //Obj *ret_buffer;

  // Variable
  Obj *var;

  // Numeric literal
  StringList *val;
  /*long double fval;*/
};

NodeKind *new_ND_NULL_EXPR(); // Do nothing
NodeKind *new_ND_ADD();       // +
NodeKind *new_ND_SUB();       // -
NodeKind *new_ND_MUL();       // *
NodeKind *new_ND_DIV();       // /
NodeKind *new_ND_NEG();       // unary -
NodeKind *new_ND_MOD();       // %
NodeKind *new_ND_BITAND();    // &
NodeKind *new_ND_BITOR();     // |
NodeKind *new_ND_BITXOR();    // ^
NodeKind *new_ND_SHL();       // <<
NodeKind *new_ND_SHR();       // >>
NodeKind *new_ND_EQ();        // ==
NodeKind *new_ND_NE();        // !=
NodeKind *new_ND_LT();        // <
NodeKind *new_ND_LE();        // <=
NodeKind *new_ND_ASSIGN();    // =
NodeKind *new_ND_COMMA();     // ,
//NodeKind *new_ND_MEMBER();    // . (struct member access)
NodeKind *new_ND_ADDR();      // unary &
NodeKind *new_ND_DEREF();     // unary *
NodeKind *new_ND_NOT();       // !
NodeKind *new_ND_BITNOT();    // ~
NodeKind *new_ND_LOGAND();    // &&
NodeKind *new_ND_LOGOR();     // ||
NodeKind *new_ND_RETURN();    // "return"
NodeKind *new_ND_IF();        // "if"
NodeKind *new_ND_FOR();       // "for" or "while"
NodeKind *new_ND_BLOCK();     // { ... }
NodeKind *new_ND_FUNCALL();   // Function call
NodeKind *new_ND_EXPR_STMT(); // Expression statement
NodeKind *new_ND_STMT_EXPR(); // Statement expression
NodeKind *new_ND_VAR();       // Variable
NodeKind *new_ND_NUM();       // Integer
NodeKind *new_ND_MEMZERO();   // Zero-clear a stack variable

ASTNode *new_node(NodeKind *kind, Token *tok);
ASTNode *new_binary(NodeKind *kind, ASTNode *lhs, ASTNode *rhs, Token *tok);
ASTNode *new_unary(NodeKind *kind, ASTNode *expr, Token *tok);
ASTNode *empty_node();
void add_type(ASTNode *node);

/* Private Implementation */
// AST node
struct NodeKind {
  int kind;
};

NodeKind *new_ND_NULL_EXPR() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 1;
  return knd;
}
NodeKind *new_ND_ADD() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 2;
  return knd;
}
NodeKind *new_ND_SUB(){
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 3;
  return knd;
}
NodeKind *new_ND_MUL() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 4;
  return knd;
}
NodeKind *new_ND_DIV(){
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 5;
  return knd;
}
NodeKind *new_ND_NEG() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 6;
  return knd;
}
NodeKind *new_ND_MOD() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 7;
  return knd;
}
NodeKind *new_ND_BITAND() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 8;
  return knd;
}
NodeKind *new_ND_BITOR() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 9;
  return knd;
}
NodeKind *new_ND_BITXOR() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 10;
  return knd;
}
NodeKind *new_ND_SHL(){
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 11;
  return knd;
}
NodeKind *new_ND_SHR() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 12;
  return knd;
}
NodeKind *new_ND_EQ() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 13;
  return knd;
}
NodeKind *new_ND_NE() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 14;
  return knd;
}
NodeKind *new_ND_LT() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 15;
  return knd;
}
NodeKind *new_ND_LE() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 16;
  return knd;
}
NodeKind *new_ND_ASSIGN() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 17;
  return knd;
}
NodeKind *new_ND_COMMA() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 18;
  return knd;
}
//NodeKind *new_ND_MEMBER();    // . (struct member access)
NodeKind *new_ND_ADDR() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 19;
  return knd;
}
NodeKind *new_ND_DEREF() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 20;
  return knd;
}
NodeKind *new_ND_NOT() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 21;
  return knd;
}
NodeKind *new_ND_BITNOT() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 22;
  return knd;
}
NodeKind *new_ND_LOGAND() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 23;
  return knd;
}
NodeKind *new_ND_LOGOR() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 24;
  return knd;
}
NodeKind *new_ND_RETURN() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 25;
  return knd;
}
NodeKind *new_ND_IF() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 26;
  return knd;
}
NodeKind *new_ND_FOR() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 27;
  return knd;
}
NodeKind *new_ND_BLOCK() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 28;
  return knd;
}
NodeKind *new_ND_FUNCALL() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 29;
  return knd;
}
NodeKind *new_ND_EXPR_STMT() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 30;
  return knd;
}
NodeKind *new_ND_STMT_EXPR() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 31;
  return knd;
}
NodeKind *new_ND_VAR() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 32;
  return knd;
}
NodeKind *new_ND_NUM() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 33;
  return knd;
}
NodeKind *new_ND_MEMZERO() {
  NodeKind *knd = alloc(NodeKind);
  knd->kind = 34;
  return knd;
}

ASTNode *new_node(NodeKind *kind, Token *tok) {
  ASTNode *node = alloc(ASTNode);
  node->kind = kind;
  node->tok = tok;
  return node;
}
ASTNode *empty_node() {
  ASTNode *node = alloc(ASTNode);
  return node;
}
ASTNode *new_binary(NodeKind *kind, ASTNode *lhs, ASTNode *rhs, Token *tok) {
  ASTNode *node = new_node(kind, tok);
  node->lhs = lhs;
  node->rhs = rhs;
  return node;
}
ASTNode *new_unary(NodeKind *kind, ASTNode *expr, Token *tok) {
  ASTNode *node = new_node(kind, tok);
  node->lhs = expr;
  return node;
}

void add_type(ASTNode *node) {
  
  if (node == NULL || node->ty != NULL) {
  } else {

    add_type(node->lhs);
    add_type(node->rhs);
    add_type(node->cond);
    add_type(node->then);
    add_type(node->els);
    add_type(node->init);
    add_type(node->inc);

    for (ASTNode *n = node->body; n != NULL; n = n->next)
      add_type(n);
    for (ASTNode *n = node->args; n != NULL; n = n->next)
      add_type(n);

    if (node->kind == NULL)
      error("node without a kind");

    if (node->kind->kind == 33) { // ND_NUM
      node->ty = new_ty_int();
    } else if (node->kind->kind == 2 || // ND_ADD
               node->kind->kind == 3 || // ND_SUB
               node->kind->kind == 4 || // ND_MUL
               node->kind->kind == 5 || // ND_DIV
               node->kind->kind == 7 || // ND_MOD
               node->kind->kind == 8 || // ND_BITAND
               node->kind->kind == 9 || // ND_BITOR
               node->kind->kind == 10 // ND_BITXOR
              ) {
      if (same_typekind(node->lhs->ty, node->rhs->ty)) {
        node->ty = node->lhs->ty;
      } else {
        error("binary op on different types");
      }
    } else if (node->kind->kind == 6) { // ND_NEG:
      if (is_INT(node->lhs->ty))
        node->ty = node->lhs->ty;
      else
        error("NEG not supported for non-int types");
    } else if (node->kind->kind == 17) { // ND_ASSIGN
      node->ty = node->lhs->ty;
    } else if (node->kind->kind == 13 ||  // ND_EQ
               node->kind->kind == 14 ||  // ND_NE
               node->kind->kind == 15 ||  // ND_LT
               node->kind->kind == 16  // ND_LE
              ) {
      node->ty = new_ty_int();
    } else if (node->kind->kind == 29) { //ND_FUNCALL
      node->ty = node->func_ty->return_ty;
    } else if (node->kind->kind == 21 ||  // ND_NOT
               node->kind->kind == 24 ||  // ND_LOGOR
               node->kind->kind == 23  // ND_LOGAND
              ) {
      node->ty = new_ty_int();
    } else if (node->kind->kind == 22 ||  // ND_BITNOT
               node->kind->kind == 11 ||  // ND_SHL
               node->kind->kind == 12  // ND_SHR
              ) {
      node->ty = node->lhs->ty;
    } else if (node->kind->kind == 32) {  // ND_VAR
      node->ty = node->var->ty;
    } else if (node->kind->kind == 18) {  // ND_COMMA
      node->ty = node->rhs->ty;
    }
    /*case ND_MEMBER:
      node->ty = node->member->ty;
      return;*/
    else if (node->kind->kind == 19) { // ND_ADDR
      Type *ty = node->lhs->ty;
      node->ty = pointer_to(ty);

    } else if (node->kind->kind == 20) { // ND_DEREF
      if (node->lhs->ty->base == NULL)
        error("invalid pointer dereference");
      if (is_VOID(node->lhs->ty->base))
        error("dereferencing a void pointer");
      node->ty = node->lhs->ty->base;

    } else if (node->kind->kind == 31) {  //ND_STMT_EXPR
      if (node->body != NULL) {
        ASTNode *stmt = node->body;
        while (stmt->next != NULL)
          stmt = stmt->next;

        if (stmt->kind == NULL)
          error("node without kind");

        if (stmt->kind->kind == 30) { //ND_EXPR_STMT
          node->ty = stmt->lhs->ty;
        }
      } else {
        error("statement expression returning void is not supported");
      }
    }
  }
}

//-------------Parser--------------------------------------------------------------------------------------
// Recursive descent parser for C

// Most functions in this file are named after the symbols they are
// supposed to read from an input token list. For example, stmt() is
// responsible for reading a statement from a token list. The function
// then construct an AST node representing a statement.

// Each function conceptually returns two values, an AST node and
// remaining part of the input tokens. Since C doesn't support
// multiple return values, the remaining tokens are returned to the
// caller via a pointer argument. --- This is important for memory safety verification

/* Public Interface */
Obj *parse(Token *tok);


/* Private Interface */
typedef struct Scope Scope;
typedef struct VarAttr VarAttr;

VarAttr *new_attr();

// Types
bool is_typename(Token *tok, Scope *scope); // determines if the token is a typename
Type *declspec(Token **rest, Token *tok, VarAttr *attr, Scope *scope);
//Type *typename(Token **rest, Token *tok); // type-name is declspec abstract-declarator (calls both of these functions and that's it)
                                                 // abstract-declarator is *(or more than one + const | volatile | restrict) (abstract-declarator) type-suffix
//Type *enum_specifier(Token **rest, Token *tok, Scope *scope);
//Type *typeof_specifier(Token **rest, Token *tok); // advanced feature not implementing
Type *type_suffix(Token **rest, Token *tok, Type *ty, Scope *scope);
Type *declarator(Token **rest, Token *tok, Type *ty, Scope *scope);
ASTNode *declaration(Token **rest, Token *tok, Type *basety, VarAttr *attr, Scope **scope, Obj **locals);
//Type *struct_decl(Token **rest, Token *tok, Scope *scope); // relies on struct_union_decl -- does bit manipulation to set member offsets after parsing
                                                    // used in declspec
                                                    // Can probably remove anonymous struct members; sufficient complexity in handling structs to ignore other stuff

// Statements
ASTNode *compound_stmt(Token **rest, Token *tok, Scope **scope, Obj **globals, Obj **locals);
ASTNode *stmt(Token **rest, Token *tok, Scope **scope, Obj **globals, Obj **locals);

// Expressions
ASTNode *expr_stmt(Token **rest, Token *tok, Scope *scope);
ASTNode *expr(Token **rest, Token *tok, Scope *scope);
//int64_t eval(Node *node);
//int64_t eval2(Node *node, char ***label);
//int64_t eval_rval(Node *node, char ***label);
//bool is_const_expr(Node *node);
ASTNode *assign(Token **rest, Token *tok, Scope *scope);
ASTNode *logor(Token **rest, Token *tok, Scope *scope);
//double eval_double(Node *node);
//ASTNode *conditional(Token **rest, Token *tok);
ASTNode *logand(Token **rest, Token *tok, Scope *scope);
ASTNode *bitor(Token **rest, Token *tok, Scope *scope);
ASTNode *bitxor(Token **rest, Token *tok, Scope *scope);
ASTNode *bitand(Token **rest, Token *tok, Scope *scope);
ASTNode *equality(Token **rest, Token *tok, Scope *scope);
ASTNode *relational(Token **rest, Token *tok, Scope *scope);
ASTNode *shift(Token **rest, Token *tok, Scope *scope);
ASTNode *add(Token **rest, Token *tok, Scope *scope);
ASTNode *new_add(ASTNode *lhs, ASTNode *rhs, Token *tok);
ASTNode *new_sub(ASTNode *lhs, ASTNode *rhs, Token *tok);
ASTNode *mul(Token **rest, Token *tok, Scope *scope);
//Member *get_struct_member(Type *ty, Token *tok);
ASTNode *postfix(Token **rest, Token *tok, Scope *scope);
ASTNode *funcall(Token **rest, Token *tok, ASTNode *node, Scope *scope);
ASTNode *unary(Token **rest, Token *tok, Scope *scope);
ASTNode *primary(Token **rest, Token *tok, Scope *scope);
Token *parse_typedef(Token *tok, Type *basety, Scope *scope);
bool is_function(Token *tok, Scope *scope);
Token *function(Token *tok, Type *basety, VarAttr *attr, Scope **scope, Obj **globals);
//static Token *global_variable(Token *tok, Type *basety, VarAttr *attr); // more wide sweeping feature extension; remove now to save time ; POSSIBLE FEATURE EXTENSION


/* Private Implementation */

// Helpful strings
StringList *str_void() {
  StringList *str = new_stringlist();
  add_char(str,'v');
  add_char(str,'o');
  add_char(str,'i');
  add_char(str,'d');
  return str;
}
StringList *str_bool() {
  StringList *str = new_stringlist();
  add_char(str,'_');
  add_char(str,'B');
  add_char(str,'o');
  add_char(str,'o');
  add_char(str,'l');
  return str;
}
StringList *str_char() {
  StringList *str = new_stringlist();
  add_char(str,'c');
  add_char(str,'h');
  add_char(str,'a');
  add_char(str,'r');
  return str;
}
StringList *str_short() {
  StringList *str = new_stringlist();
  add_char(str,'s');
  add_char(str,'h');
  add_char(str,'o');
  add_char(str,'r');
  add_char(str,'t');
  return str;
}
StringList *str_int() {
  StringList *str = new_stringlist();
  add_char(str,'i');
  add_char(str,'n');
  add_char(str,'t');
  return str;
}
StringList *str_long() {
  StringList *str = new_stringlist();
  add_char(str,'l');
  add_char(str,'o');
  add_char(str,'n');
  add_char(str,'g');
  return str;
}
StringList *str_struct() {
  StringList *str = new_stringlist();
  add_char(str,'s');
  add_char(str,'t');
  add_char(str,'r');
  add_char(str,'u');
  add_char(str,'c');
  add_char(str,'t');
  return str;
}
StringList *str_typedef() {
  StringList *str = new_stringlist();
  add_char(str,'t');
  add_char(str,'y');
  add_char(str,'p');
  add_char(str,'e');
  add_char(str,'d');
  add_char(str,'e');
  add_char(str,'f');
  return str;
}
StringList *str_enum() {
  StringList *str = new_stringlist();
  add_char(str,'e');
  add_char(str,'n');
  add_char(str,'u');
  add_char(str,'m');
  return str;
}
StringList *str_static() {
  StringList *str = new_stringlist();
  add_char(str,'s');
  add_char(str,'t');
  add_char(str,'a');
  add_char(str,'t');
  add_char(str,'i');
  add_char(str,'c');
  return str;
}
StringList *str_extern() {
  StringList *str = new_stringlist();
  add_char(str,'e');
  add_char(str,'x');
  add_char(str,'t');
  add_char(str,'e');
  add_char(str,'r');
  add_char(str,'n');
  return str;
}
StringList *str_signed() {
  StringList *str = new_stringlist();
  add_char(str,'s');
  add_char(str,'i');
  add_char(str,'g');
  add_char(str,'n');
  add_char(str,'e');
  add_char(str,'d');
  return str;
}
StringList *str_unsigned() {
  StringList *str = new_stringlist();
  add_char(str,'u');
  add_char(str,'n');
  add_char(str,'s');
  add_char(str,'i');
  add_char(str,'g');
  add_char(str,'n');
  add_char(str,'e');
  add_char(str,'d');
  return str;
}
StringList *str_const() {
  StringList *str = new_stringlist();
  add_char(str,'c');
  add_char(str,'o');
  add_char(str,'n');
  add_char(str,'s');
  add_char(str,'t');
  return str;
}
StringList *str_volatile() {
  StringList *str = new_stringlist();
  add_char(str,'v');
  add_char(str,'o');
  add_char(str,'l');
  add_char(str,'a');
  add_char(str,'t');
  add_char(str,'i');
  add_char(str,'l');
  add_char(str,'e');
  return str;
}
StringList *str_auto() {
  StringList *str = new_stringlist();
  add_char(str,'a');
  add_char(str,'u');
  add_char(str,'t');
  add_char(str,'o');
  return str;
}
StringList *str_register() {
  StringList *str = new_stringlist();
  add_char(str,'r');
  add_char(str,'e');
  add_char(str,'g');
  add_char(str,'i');
  add_char(str,'s');
  add_char(str,'t');
  add_char(str,'e');
  add_char(str,'r');
  return str;
}
StringList *str_restrict() {
  StringList *str = new_stringlist();
  add_char(str,'r');
  add_char(str,'e');
  add_char(str,'s');
  add_char(str,'t');
  add_char(str,'r');
  add_char(str,'i');
  add_char(str,'c');
  add_char(str,'t');
  return str;
}
StringList *str_float() {
  StringList *str = new_stringlist();
  add_char(str,'f');
  add_char(str,'l');
  add_char(str,'o');
  add_char(str,'a');
  add_char(str,'t');
  return str;
}
StringList *str_double() {
  StringList *str = new_stringlist();
  add_char(str,'d');
  add_char(str,'o');
  add_char(str,'u');
  add_char(str,'b');
  add_char(str,'l');
  add_char(str,'e');
  return str;
}
StringList *str_inline() {
  StringList *str = new_stringlist();
  add_char(str,'i');
  add_char(str,'n');
  add_char(str,'l');
  add_char(str,'i');
  add_char(str,'n');
  add_char(str,'e');
  return str;
}
StringList *str_oparen() {
  StringList *str = new_stringlist();
  add_char(str,'(');
  return str;
}
StringList *str_cparen() {
  StringList *str = new_stringlist();
  add_char(str,')');
  return str;
}
StringList *str_obracket() {
  StringList *str = new_stringlist();
  add_char(str,'{');
  return str;
}
StringList *str_cbracket() {
  StringList *str = new_stringlist();
  add_char(str,'}');
  return str;
}
StringList *str_eq() {
  StringList *str = new_stringlist();
  add_char(str,'=');
  return str;
}
StringList *str_comma() {
  StringList *str = new_stringlist();
  add_char(str,',');
  return str;
}
StringList *str_semicolon() {
  StringList *str = new_stringlist();
  add_char(str,';');
  return str;
}
StringList *str_colon() {
  StringList *str = new_stringlist();
  add_char(str,':');
  return str;
}
StringList *str_star() {
  StringList *str = new_stringlist();
  add_char(str,'*');
  return str;
}
StringList *str_logor() {
  StringList *str = new_stringlist();
  add_char(str,'|');
  add_char(str,'|');
  return str;
}
StringList *str_logand() {
  StringList *str = new_stringlist();
  add_char(str,'&');
  add_char(str,'&');
  return str;
}
StringList *str_bitor() {
  StringList *str = new_stringlist();
  add_char(str,'|');
  return str;
}
StringList *str_bitxor() {
  StringList *str = new_stringlist();
  add_char(str,'^');
  return str;
}
StringList *str_bitand() {
  StringList *str = new_stringlist();
  add_char(str,'&');
  return str;
}
StringList *str_logeq() {
  StringList *str = new_stringlist();
  add_char(str,'=');
  add_char(str,'=');
  return str;
}
StringList *str_logneq() {
  StringList *str = new_stringlist();
  add_char(str,'!');
  add_char(str,'=');
  return str;
}
StringList *str_lt() {
  StringList *str = new_stringlist();
  add_char(str,'<');
  return str;
}
StringList *str_le() {
  StringList *str = new_stringlist();
  add_char(str,'<');
  add_char(str,'=');
  return str;
}
StringList *str_gt() {
  StringList *str = new_stringlist();
  add_char(str,'>');
  return str;
}
StringList *str_ge() {
  StringList *str = new_stringlist();
  add_char(str,'>');
  add_char(str,'=');
  return str;
}
StringList *str_bitshl() {
  StringList *str = new_stringlist();
  add_char(str,'<');
  add_char(str,'<');
  return str;
}
StringList *str_bitshr() {
  StringList *str = new_stringlist();
  add_char(str,'>');
  add_char(str,'>');
  return str;
}
StringList *str_add() {
  StringList *str = new_stringlist();
  add_char(str,'+');
  return str;
}
StringList *str_sub() {
  StringList *str = new_stringlist();
  add_char(str,'-');
  return str;
}
StringList *str_mul() {
  StringList *str = new_stringlist();
  add_char(str,'*');
  return str;
}
StringList *str_div() {
  StringList *str = new_stringlist();
  add_char(str,'/');
  return str;
}
StringList *str_mod() {
  StringList *str = new_stringlist();
  add_char(str,'%');
  return str;
}
StringList *str_lognot() {
  StringList *str = new_stringlist();
  add_char(str,'!');
  return str;
}
StringList *str_bitnot() {
  StringList *str = new_stringlist();
  add_char(str,'~');
  return str;
}
StringList *str_return() {
  StringList *str = new_stringlist();
  add_char(str,'r');
  add_char(str,'e');
  add_char(str,'t');
  add_char(str,'u');
  add_char(str,'r');
  add_char(str,'n');
  return str;
}
StringList *str_if() {
  StringList *str = new_stringlist();
  add_char(str,'i');
  add_char(str,'f');
  return str;
}
StringList *str_else() {
  StringList *str = new_stringlist();
  add_char(str,'e');
  add_char(str,'l');
  add_char(str,'s');
  add_char(str,'e');
  return str;
}
StringList *str_while() {
  StringList *str = new_stringlist();
  add_char(str,'w');
  add_char(str,'h');
  add_char(str,'i');
  add_char(str,'l');
  add_char(str,'e');
  return str;
}

void unreachable() {
  error("internal parser error");
}

// Scope for local variables, global variables, typedefs
// or enum constants
typedef struct VarScope VarScope;
struct VarScope {
  Obj *var;
  Type *type_def;
  //Type *enum_ty;
  //int enum_val;
};

typedef struct VarScopeMap VarScopeMap;
struct VarScopeMap {
  StringList *key;
  VarScope *val;
  VarScopeMap *next;
};

typedef struct TagScopeMap TagScopeMap;
struct TagScopeMap {
  StringList *key;
  Type *val;
  TagScopeMap *next;
};

VarScopeMap *new_varscopemap() {
  VarScopeMap *vsm = alloc(VarScopeMap);
  vsm->key = NULL;
  vsm->val = NULL;
  vsm->next = NULL;
  return vsm;
}
TagScopeMap *new_tagscopemap() {
  TagScopeMap *tsm = alloc(TagScopeMap);
  tsm->key = NULL;
  tsm->val = NULL;
  tsm->next = NULL;
  return tsm; 
}

VarScope *varscopemap_get(VarScopeMap *map, StringList *key) {
  if (map != NULL) {  
    VarScopeMap *curr = map;
    VarScope *res = NULL;
    while (curr != NULL && res == NULL) {
      if (equals(curr->key, key))
        res = curr->val;
      curr = curr->next;
    }
    return res;
  } else {
    return NULL;
  }
}
Type *tagscopemap_get(TagScopeMap *map, StringList *key) {
  if (map != NULL) {  
    TagScopeMap *curr = map;
    Type *res = NULL;
    while (curr != NULL && res == NULL) {
      if (equals(curr->key, key))
        res = curr->val;
      curr = curr->next;
    }
    return res;
  } else {
    return NULL;
  }
}

// Puts value in map at key returning any previously found value (NULL otherwise)
VarScope *varscopemap_put(VarScopeMap *map, StringList *key, VarScope *val) {
  if (map != NULL) {  
    VarScopeMap *curr = map;
    VarScopeMap *prev = map;
    VarScope *res = NULL;
    while (curr != NULL && res == NULL) {
      if (equals(curr->key, key)) {
        res = curr->val;
        curr->val = val;
      }
      prev = curr;
      curr = curr->next;
    }
    if (res == NULL) {
      VarScopeMap *newvsm = new_varscopemap();
      newvsm->key = key;
      newvsm->val = val;
      newvsm->next = NULL;
      prev->next = newvsm;
    }
    return res;
  } else {
    error("Can't add to NULL map pointer");
  }
}
// Puts value in map at key returning any previously found value (NULL otherwise)
Type *tagscopemap_put(TagScopeMap *map, StringList *key, Type *val) {
  if (map != NULL) {  
    TagScopeMap *curr = map;
    TagScopeMap *prev = map;
    Type *res = NULL;
    while (curr != NULL && res == NULL) {
      if (equals(curr->key, key)) {
        res = curr->val;
        curr->val = val;
      }
      prev = curr;
      curr = curr->next;
    }
    if (res == NULL) {
      TagScopeMap *newtsm = new_tagscopemap();
      newtsm->key = key;
      newtsm->val = val;
      newtsm->next = NULL;
      prev->next = newtsm;
    }
    return res;
  } else {
    error("Can't add to NULL map pointer");
  }
}

// Represents a block scope.
struct Scope {
  Scope *next;

  // C has two block scopes; one is for variables/typedefs and
  // the other is for struct/enum tags.
  VarScopeMap *vars;
  TagScopeMap *tags;
};

Scope *new_scope() {
  Scope *scope = alloc(Scope);
  scope->next = NULL;
  scope->vars = new_varscopemap();
  scope->tags = new_tagscopemap();
  return scope;
}

// Assume scope not null
VarScope *push_scope(Scope *scope, StringList *name) {
  VarScope *sc = alloc(VarScope);
  varscopemap_put(scope->vars, name, sc);
  return sc;
}

// Assume scope not null
void push_tag_scope(Scope *scope, StringList *name, Type *ty) {
    tagscopemap_put(scope->tags, name, ty);
}

// Assume scope not null
void enter_scope(Scope **scope) {
  Scope *sc = new_scope();
  sc->next = *scope;
  *scope = sc; 
}

// Assume scope and *scope not null
void leave_scope(Scope **scope) {
  *scope = (*scope)->next;
}

// Variable attributes such as typedef or extern (only typedef supported rn).
struct VarAttr {
  bool is_typedef;
  int align;
};

VarAttr *new_attr() {
  VarAttr *attr = alloc(VarAttr);
  attr->is_typedef = false;
  attr->align = 0;
  return attr;
}

Obj *new_var(Scope *scope, StringList *name, Type *ty) {
  Obj *var = alloc(Obj);
  var->name = name;
  var->ty = ty;
  var->align = ty->align;
  VarScope *tmp = push_scope(scope, name);
  tmp->var = var;
  return var;
}

Obj *new_lvar(Scope *scope, Obj **locals, StringList *name, Type *ty) {
  Obj *var = new_var(scope, name, ty);
  var->is_local = true;
  var->next = *locals;
  *locals = var;
  return var;
}

Obj *new_gvar(Scope *scope, Obj **globals, StringList *name, Type *ty) {
  Obj *var = new_var(scope, name, ty);
  var->next = *globals;
  var->is_definition = true;
  *globals = var;
  return var;
}

// Find a variable by name.
VarScope *find_var(Token *tok, Scope *scope) {
  for (Scope *sc = scope; sc != NULL; sc = sc->next) {
    VarScope *sc2 = varscopemap_get(sc->vars, name(tok));
    if (sc2 != NULL)
      return sc2;
  }
  return NULL;
}

// Find a tag by name
Type *find_tag(Token *tok, Scope *scope) {
  for (Scope *sc = scope; sc != NULL; sc = sc->next) {
    Type *ty = tagscopemap_get(sc->tags, name(tok));
    if (ty != NULL)
      return ty;
  }
  return NULL;
}

// logor = logand ("||" logand)*
ASTNode *logor(Token **rest, Token *tok, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ASTNode *node = logand(rst, tok, scope);
  tok = *rst;
  while (equal(tok, str_logor())) {
    Token *start = tok;
    *rst = tok;
    node = new_binary(new_ND_LOGOR(), node, logand(rst, tok->next, scope), start);
    tok = *rst;
  }
  *rest = tok;
  return node;
}
// logand = bitor ("&&" bitor)*
ASTNode *logand(Token **rest, Token *tok, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ASTNode *node = bitor(rst, tok, scope);
  tok = *rst;
  while (equal(tok, str_logand())) {
    Token *start = tok;
    *rst = tok;
    node = new_binary(new_ND_LOGAND(), node, bitor(rst, tok->next, scope), start);
    tok = *rst;
  }
  *rest = tok;
  return node;
}
// bitor = bitxor ("|" bitxor)*
ASTNode *bitor(Token **rest, Token *tok, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ASTNode *node = bitxor(rst, tok, scope);
  tok = *rst;
  while (equal(tok, str_bitor())) {
    Token *start = tok;
    *rst = tok;
    node = new_binary(new_ND_BITOR(), node, bitxor(rst, tok->next, scope), start);
    tok = *rst;
  }
  *rest = tok;
  return node;
}
// bitxor = bitand ("^" bitand)*
ASTNode *bitxor(Token **rest, Token *tok, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ASTNode *node = bitand(rst, tok, scope);
  tok = *rst;
  while (equal(tok, str_bitxor())) {
    Token *start = tok;
    *rst = tok;
    node = new_binary(new_ND_BITXOR(), node, bitand(rst, tok->next, scope), start);
    tok = *rst;
  }
  *rest = tok;
  return node;
}
// bitand = equality ("&" equality)*
ASTNode *bitand(Token **rest, Token *tok, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ASTNode *node = equality(rst, tok, scope);
  tok = *rst;
  while (equal(tok, str_bitand())) {
    Token *start = tok;
    *rst = tok;
    node = new_binary(new_ND_BITAND(), node, equality(rst, tok->next, scope), start);
    tok = *rst;
  }
  *rest = tok;
  return node;
}
// equality = relational ("==" relational | "!=" relational)*
ASTNode *equality(Token **rest, Token *tok, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ASTNode *node = relational(rst, tok, scope);
  tok = *rst;

  bool break_loop = false;
  while (!break_loop) {
    Token *start = tok;

    if (equal(tok, str_logeq())) {
      *rst = tok;
      node = new_binary(new_ND_EQ(), node, relational(rst, tok->next, scope), start);
      tok = *rst;
    } else if (equal(tok, str_logneq())) {
      *rst = tok;
      node = new_binary(new_ND_NE(), node, relational(rst, tok->next, scope), start);
      tok = *rst;
    } else {
      *rest = tok;
      break_loop = true;
    }
  }
  return node;
}
// relational = shift ("<" shift | "<=" shift | ">" shift | ">=" shift)*
ASTNode *relational(Token **rest, Token *tok, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ASTNode *node = shift(rst, tok, scope);
  tok = *rst;

  bool break_loop = false;
  while (!break_loop) {
    Token *start = tok;

    if (equal(tok, str_lt())) {
      *rst = tok;
      node = new_binary(new_ND_LT(), node, shift(rst, tok->next, scope), start);
      tok = *rst;
    } else if (equal(tok, str_le())) {
      *rst = tok;
      node = new_binary(new_ND_LE(), node, shift(rst, tok->next, scope), start);
      tok = *rst;
    } else if (equal(tok, str_gt())) {
      *rst = tok;
      node = new_binary(new_ND_LT(), shift(rst, tok->next, scope), node, start);
      tok = *rst;
    } else if (equal(tok, str_ge())) {
      *rst = tok;
      node = new_binary(new_ND_LE(), shift(rst, tok->next, scope), node, start);
      tok = *rst;
    } else {
      *rest = tok;
      break_loop = true;
    }
  }
  return node;
}
// shift = add ("<<" add | ">>" add)*
ASTNode *shift(Token **rest, Token *tok, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ASTNode *node = add(rst, tok, scope);
  tok = *rst;

  bool break_loop = false;
  while (!break_loop) {
    Token *start = tok;

    if (equal(tok, str_bitshl())) {
      *rst = tok;
      node = new_binary(new_ND_SHL(), node, add(rst, tok->next, scope), start);
      tok = *rst;
    } else if (equal(tok, str_bitshr())) {
      *rst = tok;
      node = new_binary(new_ND_SHR(), node, add(rst, tok->next, scope), start);
      tok = *rst;
    } else {
      *rest = tok;
      break_loop = true;
    }
  }
  return node;
}
// Only numeric values can be added (no pointer arithmetic)
ASTNode *new_add(ASTNode *lhs, ASTNode *rhs, Token *tok) {
  add_type(lhs);
  add_type(rhs);

  // num + num
  if (is_numeric(lhs->ty) && is_numeric(rhs->ty)) {
    return new_binary(new_ND_ADD(), lhs, rhs, tok);
  } else {
    error("Only numerics can be added");
  }
}
// Only numerics can be subtracted (no pointer arithmetic)
ASTNode *new_sub(ASTNode *lhs, ASTNode *rhs, Token *tok) {
  add_type(lhs);
  add_type(rhs);

  // num - num
  if (is_numeric(lhs->ty) && is_numeric(rhs->ty)) {
    return new_binary(new_ND_SUB(), lhs, rhs, tok);
  } else {
    error("invalid operands");
  }
}
// add = mul ("+" mul | "-" mul)*
ASTNode *add(Token **rest, Token *tok, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ASTNode *node = mul(rst, tok, scope);
  tok = *rst;

  bool break_loop = false;
  while(!break_loop) {
    Token *start = tok;

    if (equal(tok, str_add())) {
      *rst = tok;
      node = new_add(node, mul(rst, tok->next, scope), start);
      tok = *rst;
    } else if (equal(tok, str_sub())) {
      *rst = tok;
      node = new_sub(node, mul(rst, tok->next, scope), start);
      tok = *rst;
    } else {
      *rest = tok;
      break_loop = true;
    }
  }
  return node;
}
// mul = unary ("*" unary | "/" unary | "%" unary)*
ASTNode *mul(Token **rest, Token *tok, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ASTNode *node = unary(rst, tok, scope);
  tok = *rst;

  bool break_loop = false;
  while (!break_loop) {
    Token *start = tok;

    if (equal(tok, str_mul())) {
      *rst = tok;
      node = new_binary(new_ND_MUL(), node, unary(rst, tok->next, scope), start);
      tok = *rst;
    } else if (equal(tok, str_div())) {
      *rst = tok;
      node = new_binary(new_ND_DIV(), node, unary(rst, tok->next, scope), start);
      tok = *rst;
    } else if (equal(tok, str_mod())) {
      *rst = tok;
      node = new_binary(new_ND_MOD(), node, unary(rst, tok->next, scope), start);
      tok = *rst;
    } else {
      *rest = tok;
      break_loop = true;
    }
  }
  return node;
}
// unary = ("+" | "-" | "*" | "&" | "!" | "~") unary
//       | postfix
ASTNode *unary(Token **rest, Token *tok, Scope *scope) {
  if (equal(tok, str_add())) {
    return unary(rest, tok->next, scope);

  } else if (equal(tok, str_sub())) {
    return new_unary(new_ND_NEG(), unary(rest, tok->next, scope), tok);
  
  } else if (equal(tok, str_bitand())) {
    ASTNode *lhs = unary(rest, tok->next, scope);
    add_type(lhs);
    //if (lhs->kind == ND_MEMBER && lhs->member->is_bitfield)
    //  error("cannot take address of bitfield");
    return new_unary(new_ND_ADDR(), lhs, tok);
  
  } else if (equal(tok, str_mul())) {
    // [https://www.sigbus.info/n1570#6.5.3.2p4] This is an oddity
    // in the C spec, but dereferencing a function shouldn't do
    // anything. If foo is a function, `*foo`, `**foo` or `*****foo`
    // are all equivalent to just `foo`.
    ASTNode *node = unary(rest, tok->next, scope);
    add_type(node);
    if (is_FUNC(node->ty))
      return node;
    else 
      return new_unary(new_ND_DEREF(), node, tok);
  
  } else if (equal(tok, str_lognot())) {
    return new_unary(new_ND_NOT(), unary(rest, tok->next, scope), tok);
  
  } else if (equal(tok, str_bitnot())) {
    return new_unary(new_ND_BITNOT(), unary(rest, tok->next, scope), tok);

  } else {
    return postfix(rest, tok, scope);
  }
}
// postfix = ident "(" func-args ")" postfix-tail*
//         | primary postfix-tail*
//
// postfix-tail = "(" func-args ")"
ASTNode *postfix(Token **rest, Token *tok, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ASTNode *node = primary(rst, tok, scope);
  tok = *rst;

  bool break_loop = false;
  while (!break_loop) {
    if (equal(tok, str_oparen())) {
      *rst = tok;
      node = funcall(rst, tok->next, node, scope);
      tok = *rst;
    /*} else if (equal(tok, ".")) {
      node = struct_ref(node, tok->next);
      tok = tok->next->next;
      continue;
    } else if (equal(tok, "->")) {
      // x->y is short for (*x).y
      node = new_unary(ND_DEREF, node, tok);
      node = struct_ref(node, tok->next);
      tok = tok->next->next;
      continue;*/
    } else  {
      *rest = tok;
      break_loop = true;
    }
  }
  return node;
}
// primary = "(" expr ")"
//         | ident
//         | num
ASTNode *primary(Token **rest, Token *tok, Scope *scope) {
  Token *start = tok;
  Token **rst = alloc(Token*);
  *rst = tok;

  if (equal(tok, str_oparen())) {
    ASTNode *node = expr(rst, tok->next, scope);
    tok = *rst;
    *rest = skip(tok, str_cparen());
    return node;

  } else if (is_IDENT(tok)) {
    // Variable or enum constant
    VarScope *sc = find_var(tok, scope);
    *rest = tok->next;

    if (sc != NULL) {
      if (sc->var != NULL) {
        ASTNode *node = new_node(new_ND_VAR(), tok);
        node->var = sc->var;
        return node;

      //else if (sc->enum_ty != NULL)
      //  return new_num(sc->enum_val, tok);
      } else if (equal(tok->next, str_oparen())) {
        error("implicit declaration of a function");
      } else {
        error("undefined variable");
      }
    } else {
      if (equal(tok->next, str_oparen()))
        error("implicit declaration of a function");
      else 
        error("undefined variable");
    }
  } else if (is_NUM(tok)) {
    ASTNode *node;
    node = new_node(new_ND_NUM(), tok);
    node->val = name(tok);

    node->ty = tok->ty;
    *rest = tok->next;
    return node;
  } else {
    error("expected an expression");
  }
}
// funcall = (assign ("," assign)*)? ")"
ASTNode *funcall(Token **rest, Token *tok, ASTNode *fn, Scope *scope) {
  add_type(fn);

  if (!is_FUNC(fn->ty) &&
      (!is_PTR(fn->ty) || !is_FUNC(fn->ty->base)))
    error("not a function");
  
  Type *ty = NULL;
  if (is_FUNC(fn->ty))
    ty = fn->ty;
  else
    ty = fn->ty->base;

  Type *param_ty = ty->params;

  ASTNode *head = empty_node();
  ASTNode *cur = head;

  Token **rst = alloc(Token*);

  while (!equal(tok, str_cparen())) {
    if (cur != head)
      tok = skip(tok, str_comma());

    *rst = tok;
    ASTNode *arg = assign(rst, tok, scope);
    tok = *rst;
    add_type(arg);

    if (param_ty != NULL) {
      param_ty = param_ty->next;
    } else {
      error("too many args");
    }

    cur->next = arg;
    cur = cur->next;
  }

  if (param_ty != NULL)
    error("too few arguments");

  *rest = skip(tok, str_cparen());

  ASTNode *node = new_unary(new_ND_FUNCALL(), fn, tok);
  node->func_ty = ty;
  node->ty = ty->return_ty;
  node->args = head->next;

  // If a function returns a struct, it is caller's responsibility
  // to allocate a space for the return value.
  //if (node->ty->kind == TY_STRUCT || node->ty->kind == TY_UNION)
  //  node->ret_buffer = new_lvar("", node->ty);
  return node;
}

// assign    = logor (assign-op assign)?
// assign-op = "="
ASTNode *assign(Token **rest, Token *tok, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ASTNode *node = logor(rst, tok, scope);
  tok = *rst;

  if (equal(tok, str_eq())) {
    return new_binary(new_ND_ASSIGN(), node, assign(rest, tok->next, scope), tok);
  } else {
    *rest = tok;
    return node;
  }
}

// expr-stmt = expr? ";"
ASTNode *expr_stmt(Token **rest, Token *tok, Scope *scope) {
  if (equal(tok, str_semicolon())) {
    *rest = tok->next;
    return new_node(new_ND_BLOCK(), tok);
  } else {
    ASTNode *node = new_node(new_ND_EXPR_STMT(), tok);
    Token **rst = alloc(Token*);
    *rst = tok;
    node->lhs = expr(rst, tok, scope);
    tok = *rst;
    *rest = skip(tok, str_semicolon());
    return node;
  }
}

// expr = assign ("," expr)?
ASTNode *expr(Token **rest, Token *tok, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ASTNode *node = assign(rst, tok, scope);
  tok = *rst;

  if (equal(tok, str_comma())) {
    return new_binary(new_ND_COMMA(), node, expr(rest, tok->next, scope), tok);
  } else {
    *rest = tok;
    return node;
  }
}

// stmt = "return" expr? ";"
//      | "if" "(" expr ")" stmt ("else" stmt)?
//      | "while" "(" expr ")" stmt
//      | "{" compound-stmt
//      | expr-stmt
ASTNode *stmt(Token **rest, Token *tok, Scope **scope, Obj **globals, Obj **locals) {
  Token **rst = alloc(Token*);

  if (equal(tok, str_return())) {
    ASTNode *node = new_node(new_ND_RETURN(), tok);
    if (consume(rest, tok->next, str_semicolon())) {
      return node;
    } else {
      *rst = tok;
      ASTNode *exp = expr(rst, tok->next, *scope);
      tok = *rst;
      *rest = skip(tok, str_semicolon());

      add_type(exp);

      node->lhs = exp;
      return node;
    }
  
  } else if (equal(tok, str_if())) {
    ASTNode *node = new_node(new_ND_IF(), tok);
    tok = skip(tok->next, str_oparen());
    *rst = tok;
    node->cond = expr(rst, tok, *scope);
    tok = *rst;
    tok = skip(tok, str_cparen());
    *rst = tok;
    node->then = stmt(rst, tok, scope, globals, locals);
    tok = *rst;
    if (equal(tok, str_else())) {
      *rst = tok;
      node->els = stmt(rst, tok->next, scope, globals, locals);
      tok = *rst;
    }
    *rest = tok;
    return node;
  
  } else if (equal(tok, str_while())) {
    ASTNode *node = new_node(new_ND_FOR(), tok);
    tok = skip(tok->next, str_oparen());
    *rst = tok;
    node->cond = expr(rst, tok, *scope);
    tok = *rst;
    tok = skip(tok, str_cparen());

    node->then = stmt(rest, tok, scope, globals, locals);

    return node;
  } else if (equal(tok, str_obracket())) {
    return compound_stmt(rest, tok->next, scope, globals, locals);
  } else {
    return expr_stmt(rest, tok, *scope);
  }
}

// compound-stmt = (typedef | declaration | stmt)* "}"
ASTNode *compound_stmt(Token **rest, Token *tok, Scope **scope, Obj **globals, Obj **locals) {
  ASTNode *node = new_node(new_ND_BLOCK(), tok);
  ASTNode *head = empty_node();
  ASTNode *cur = head;
  Token **rst = alloc(Token*);

  enter_scope(scope);

  bool continue_loop = false;
  while (!equal(tok, str_cbracket())) {
    continue_loop = false;

    if (is_typename(tok,*scope) && !equal(tok->next, str_colon())) {
      VarAttr *attr = new_attr();
      *rst = tok;
      Type *basety = declspec(rst, tok, attr, *scope);
      tok = *rst;

      if (attr->is_typedef) {
        tok = parse_typedef(tok, basety, *scope);
        continue_loop = true;
      } else if (is_function(tok, *scope)) {
        tok = function(tok, basety, attr, scope, globals);
        continue_loop = true;
      } else {
        *rst = tok;
        cur->next = declaration(rst, tok, basety, attr, scope, locals);
        tok = *rst;
        cur = cur->next;
      }
    } else {
      *rst = tok;
      cur->next = stmt(rst, tok, scope, globals, locals);
      tok = *rst;
      cur = cur->next;
    }
    if (!continue_loop) {
      add_type(cur);
    }
  }

  leave_scope(scope);

  node->body = head->next;
  *rest = tok->next;
  return node;
}

// declaration = declspec (declarator ("," declarator )*)? ";"
ASTNode *declaration(Token **rest, Token *tok, Type *basety, VarAttr *attr, Scope **scope, Obj **locals) {
  Token **rst = alloc(Token*);
  int i = 0;

  while (!equal(tok, str_semicolon())) {
    if (i > 0)
      tok = skip(tok, str_comma());
    i = i + 1;

    *rst = tok;
    Type *ty = declarator(rst, tok, basety, *scope);
    tok = *rst;

    if (is_VOID(ty)) {
      error("variable declared void");
    } else if (ty_name(ty) == NULL) {
      error("variable name omitted");
    } else {
      Obj *var = new_lvar(*scope, locals, ty_name(ty), ty);
      if (attr != NULL && attr->align > 0)
        var->align = attr->align;

      if (var->ty->size < 0)
        error("variable has incomplete type");
      if (is_VOID(var->ty))
        error("variable declared void");
    }
  }

  ASTNode *node = new_node(new_ND_BLOCK(), tok);
  *rest = tok->next;
  return node;
}

Type *find_typedef(Token *tok, Scope *scope) {
  if (is_IDENT(tok)) {
    VarScope *sc = find_var(tok, scope);
    if (sc != NULL)
      return sc->type_def;
  }
  return NULL;
}

// Returns true if a given token represents a type.
bool is_typename(Token *tok, Scope *scope) {

  bool res = false;
  if (equal(tok,str_void())     || equal(tok,str_bool())     || equal(tok,str_char())   ||
      equal(tok,str_short())    || equal(tok,str_int())      || equal(tok,str_long())   ||
      equal(tok,str_struct())   || equal(tok,str_typedef())  || equal(tok,str_enum())   ||
      equal(tok,str_static())   || equal(tok,str_extern())   || equal(tok,str_signed()) ||
      equal(tok,str_const())    || equal(tok,str_volatile()) || equal(tok,str_auto())   ||
      equal(tok,str_register()) || equal(tok,str_restrict()) || equal(tok,str_float())  ||
      equal(tok,str_double())   || equal(tok,str_typedef())  || equal(tok,str_inline()) ||
      equal(tok,str_unsigned()) || find_typedef(tok,scope) != NULL
     )
    res = true;

  return res;
}

// Helper function for end of enums
/*bool consume_end(Token **rest, Token *tok) {
  if (equal(tok, str_cbracket())) {
    *rest = tok->next;
    return true;
  }

  if (equal(tok, str_comma()) && equal(tok->next, str_cbracket())) {
    *rest = tok->next->next;
    return true;
  }

  return false;
}*/

// enum-specifier = ident? "{" enum-list? "}"
//                | ident ("{" enum-list? "}")?
//
// enum-list      = ident ("=" num)? ("," ident ("=" num)?)* ","?
// TODO: NEED TO FINISH THIS
/*Type *enum_specifier(Token **rest, Token *tok, Scope *scope) {
  Type *ty = enum_type();

  // Read a struct tag.
  Token *tag = NULL;
  if (is_IDENT(tok)) {
    tag = tok;
    tok = tok->next;
  }

    if (tag != NULL && !equal(tok, str_obracket())) {
    Type *ty = find_tag(tag, scope);
    if (ty == NULL)
      error("unknown enum type");
    if (!is_ENUM(ty))
      error("not an enum tag");
    *rest = tok;
    return ty;
  }

  tok = skip(tok, str_obracket());

  // Read an enum-list.
  int i = 0;
  int val = 0;
  while (!consume_end(rest, tok)) {
    if (i > 0)
      tok = skip(tok, str_comma());

    i = i + 1;

    StringList *name = name(tok);
    tok = tok->next;

    if (equal(tok, str_eq()))
      val = const_expr(&tok, tok->next); // evals rhs of equals, need function evals

    VarScope *sc = push_scope(name);
    sc->enum_ty = ty;
    val = val + 1
    sc->enum_val = val;
  }

  if (tag != NULL)
    push_tag_scope(tag, ty);
  return ty;
}*/

// Parse Base Type
// declspec = ("void" | "_Bool" | "char" | "short" | "int" | "long"
//             | "typedef" | "static" | "extern" | "inline"           // static, extern, inline will produce a parser error
//             | "signed" | "unsigned"
//             | struct-decl | typedef-name      // struct-decl support in future
//             | enum-specifier                  // enum-specifier support in future
//             | "const" | "volatile" | "auto" | "register" | "restrict")+
//
// The order of typenames in a type-specifier doesn't matter. For
// example, `int long static` means the same as `static long int`.
// That can also be written as `static long` because you can omit
// `int` if `long` or `short` are specified. However, something like
// `char int` is not a valid type specifier. We have to accept only a
// limited combinations of the typenames.
//
// In this function, we count the number of occurrences of each typename
// while keeping the "current" type object that the typenames up
// until that point represent. When we reach a non-typename token,
// we returns the current type object.
Type *declspec(Token **rest, Token *tok, VarAttr *attr, Scope *scope) {
  // We use a single integer as counters for all typenames.
  // For example, bits 0 and 1 represents how many times we saw the
  // keyword "void" so far. With this, we can use a switch statement
  // as you can see below.
  
  int VOID     = 1 << 0;
  int BOOL     = 1 << 2;
  int CHAR     = 1 << 4;
  int SHORT    = 1 << 6;
  int INT      = 1 << 8;
  int LONG     = 1 << 10;
  int FLOAT    = 1 << 12;
  int DOUBLE   = 1 << 14;
  int OTHER    = 1 << 16;
  int SIGNED   = 1 << 17;
  int UNSIGNED = 1 << 18;

  Type *ty = new_ty_int();
  int counter = 0;
  bool break_loop = false;

  while (!break_loop && is_typename(tok, scope)) {
    // Handle storage class specifiers.
    if (equal(tok, str_typedef()) || equal(tok, str_static()) || equal(tok, str_extern()) ||
        equal(tok, str_inline())) {
      if (attr == NULL)
        error("storage class specifier is not allowed in this context");

      if (equal(tok, str_typedef()))
        attr->is_typedef = true;
      else if (equal(tok, str_static()))
        error("static not supported");
      else if (equal(tok, str_extern()))
        error("extern not supported");
      else
        error("inline not supported");

      /*if (attr->is_typedef &&
          (attr->is_static || attr->is_extern || attr->is_inline))
        error("typedef may not be used together with static,"
                  " extern, or inline");*/
      
      tok = tok->next;

    // These keywords are recognized but ignored.
    } else if (equal(tok, str_const()) || equal(tok, str_volatile()) ||
               equal(tok, str_auto())  || equal(tok, str_register()) ||
               equal(tok, str_restrict())) {
        
      tok = tok->next;
      
    } else {
      // Handle user-defined types.
      Type *ty2 = find_typedef(tok, scope);
      if (equal(tok, str_struct()) || equal(tok, str_enum()) ||
          ty2 != NULL) {

        if (counter > 0) {
          break_loop = true;
        } else {
          Token **rst = alloc(Token*);
          *rst = tok;
          if (equal(tok, str_struct())) {
            error("structs aren't supported yet");
          } else if (equal(tok, str_enum())) {
            //ty = enum_specifier(rst, tok->next, scope); // TODO
            //tok = *rst;
            error("enums not fully supported yet");
          } else {
            ty = ty2;
            tok = tok->next;
          }

          counter = counter + OTHER;
        }
      } else {
        // Handle built-in types.
        if (equal(tok, str_void()))
          counter = counter + VOID;
        else if (equal(tok, str_bool()))
          counter = counter + BOOL;
        else if (equal(tok, str_char()))
          counter = counter + CHAR;
        else if (equal(tok, str_short()))
          counter = counter + SHORT;
        else if (equal(tok, str_int()))
          counter = counter + INT;
        else if (equal(tok, str_long()))
          counter = counter + LONG;
        else if (equal(tok, str_float()))
          counter = counter + FLOAT;
        else if (equal(tok, str_double()))
          counter = counter + DOUBLE;
        else if (equal(tok, str_signed()))
          counter = counter | SIGNED;
        else if (equal(tok, str_unsigned()))
          counter = counter | UNSIGNED;
        else
          unreachable();

        if (counter == VOID) {
          ty = new_ty_void();
        } else if (counter == BOOL) {
          ty = new_ty_bool();
        } else if (counter == CHAR ||
                   counter == SIGNED + CHAR) {
          ty = new_ty_char();
        } else if (counter == UNSIGNED + CHAR) {
          ty = new_ty_uchar();
        } else if (counter == SHORT ||
                   counter == SHORT + INT ||
                   counter == SIGNED + SHORT ||
                   counter == SIGNED + SHORT + INT) {
          ty = new_ty_short();
        } else if (counter == UNSIGNED + SHORT ||
                   counter == UNSIGNED + SHORT + INT) {
          ty = new_ty_ushort();
        } else if (counter == INT ||
                   counter == SIGNED ||
                   counter == SIGNED + INT) {
          ty = new_ty_int();
        } else if (counter == UNSIGNED ||
                   counter == UNSIGNED + INT) {
          ty = new_ty_uint();
        } else if (counter == LONG ||
                   counter == LONG + INT ||
                   counter == LONG + LONG ||
                   counter == LONG + LONG + INT ||
                   counter == SIGNED + LONG ||
                   counter == SIGNED + LONG + INT ||
                   counter == SIGNED + LONG + LONG ||
                   counter == SIGNED + LONG + LONG + INT) {
          ty = new_ty_long();
        } else if (counter == UNSIGNED + LONG ||
                   counter == UNSIGNED + LONG + INT ||
                   counter == UNSIGNED + LONG + LONG ||
                   counter == UNSIGNED + LONG + LONG + INT) {
          ty = new_ty_ulong();
        } else if (counter == FLOAT) {
          ty = new_ty_float();
        } else if (counter == DOUBLE) {
          ty = new_ty_double();
        } else if (counter == LONG + DOUBLE) {
          ty = new_ty_ldouble();
        } else {
          error("invalid type");
        }

        tok = tok->next;

      }
    }
  }

  *rest = tok;
  return ty;
}

// func-params = ("void" | param ("," param)*)? ")"
// param       = declspec declarator
Type *func_params(Token **rest, Token *tok, Type *ty, Scope *scope) {
  if (equal(tok, str_void()) && equal(tok->next, str_cparen())) {
    *rest = tok->next->next;
    return func_type(ty);
  }

  Type *head = empty_type();
  Type *cur = head;
  Token **rst = alloc(Token*);

  while (!equal(tok, str_cparen())) {
    if (cur != head)
      tok = skip(tok, str_comma());

    *rst = tok;
    Type *ty2 = declspec(rst, tok, NULL, scope);
    tok = *rst;
    ty2 = declarator(rst, tok, ty2, scope);
    tok = *rst;

    if (is_FUNC(ty2)) {
      error("functions are not allowed to take other functions as arguments");
    }
    
    cur->next = copy_type(ty2);
    cur = cur->next;
  }

  ty = func_type(ty);
  ty->params = head->next;
  *rest = tok->next;
  return ty;
}

// type-suffix = "(" func-params
//             | 
Type *type_suffix(Token **rest, Token *tok, Type *ty, Scope *scope) {
  if (equal(tok, str_oparen()))
    return func_params(rest, tok->next, ty, scope);

  *rest = tok;
  return ty;
}

Type *pointers(Token **rest, Token *tok, Type *ty) {
  Token **rst = alloc(Token*);
  *rst = tok;
  bool consume_b = consume(rst, tok, str_star());
  tok = *rst;
  while (consume_b) {
    ty = pointer_to(ty);
    
    while (equal(tok, str_const()) || equal(tok, str_volatile()) || equal(tok, str_restrict()))
      tok = tok->next;
    
    *rst = tok;
    consume_b = consume(rst, tok, str_star());
    tok = *rst;
  }
  *rest = tok;
  return ty;
}

// declarator = pointers ("(" ident ")" | "(" declarator ")" | ident) type-suffix
Type *declarator(Token **rest, Token *tok, Type *ty, Scope *scope) {
  Token **rst = alloc(Token*);
  *rst = tok;
  ty = pointers(rst, tok, ty);
  tok = *rst;

  if (equal(tok, str_oparen())) {
    Token *start = tok;
    Type *dummy = empty_type();
    declarator(rst, start->next, dummy, scope);
    tok = *rst;
    tok = skip(tok, str_cparen());
    ty = type_suffix(rest, tok, ty, scope);
    *rst = tok;
    Type *res_ty = declarator(rst, start->next, ty, scope);
    tok = *rst;
    return res_ty;
  }

  Token *name = NULL;
  Token *name_pos = tok;

  if (is_IDENT(tok)) {
    name = tok;
    tok = tok->next;
  }

  ty = type_suffix(rest, tok, ty, scope);
  ty->name = name;
  ty->name_pos = name_pos;
  return ty;
}

// Parse Typedef
Token *parse_typedef(Token *tok, Type *basety, Scope *scope) {
  bool first = true;

  Token **rest = alloc(Token*);
  *rest = tok;
  while (!consume(rest, tok, str_semicolon())) {
    tok = *rest;
    if (!first)
      tok = skip(tok, str_comma());
    first = false;
    
    *rest = tok;
    Type *ty = declarator(rest, tok, basety, scope);
    tok = *rest;
    if (ty_name(ty) == NULL)
      error("typedef name omitted");
    VarScope *tmp = push_scope(scope, ty_name(ty));
    tmp->type_def = ty;
  }
  tok = *rest;
  return tok;
}

void create_param_lvars(Scope *scope, Obj **locals, Type *param) {
  if (param != NULL) {
    create_param_lvars(scope, locals, param->next);
    if (ty_name(param) == NULL)
      error("parameter name omitted");
    new_lvar(scope, locals, ty_name(param), param);
  }
}

Obj *find_func(Scope *scope, StringList *name) {
  Scope *sc = scope;
  while (sc->next != NULL)
    sc = sc->next;

  VarScope *sc2 = varscopemap_get(sc->vars, name);
  if (sc2 != NULL && sc2->var != NULL && sc2->var->is_function)
    return sc2->var;
  return NULL;
}

// Parse Functions
Token *function(Token *tok, Type *basety, VarAttr *attr, Scope **scope, Obj **globals) {
  Token **rst = alloc(Token*);
  *rst = tok;
  Type *ty = declarator(rst, tok, basety, *scope);
  tok = *rst;

  if (ty_name(ty) == NULL)
    error("function name omitted");
  StringList *name_str = ty_name(ty);

  Obj *fn = find_func(*scope, name_str);
  if (fn != NULL) {
    // Redeclaration
    if (!fn->is_function)
      error("redeclared as a different kind of symbol");
    if (fn->is_definition && equal(tok, str_obracket()))
      error("redefinition of function");
    fn->is_definition = fn->is_definition || equal(tok, str_obracket());
  } else {
    fn = new_gvar(*scope, globals, name_str, ty);
    fn->is_function = true;
    fn->is_definition = equal(tok, str_obracket());
  }
  
  Token **rest = alloc(Token*);
  *rest = tok;
  if (consume(rest, tok, str_semicolon())) {
    tok = *rest;
    return tok;
  }
  tok = *rest;

  Obj **locals = alloc(Obj*);
  *locals = NULL;
  enter_scope(scope);
  create_param_lvars(*scope, locals, ty->params);

  // A buffer for a struct/union return value is passed
  // as the hidden first parameter.
  /*Type *rty = ty->return_ty;
  if (rty->kind == TY_STRUCT && rty->size > 16)
    new_lvar("", pointer_to(rty));*/

  fn->params = *locals;

  tok = skip(tok, str_obracket());
  
  *rest = tok;
  fn->body = compound_stmt(rest, tok, scope, globals, locals);
  tok = *rest;
  fn->locals = *locals;
  leave_scope(scope);
  return tok;
}

// Lookahead tokens and returns true if a given token is a start
// of a function definition or declaration.
bool is_function(Token *tok, Scope *scope) {
  if (equal(tok, str_semicolon()))
    return false;

  Type *dummy = empty_type();
  Token **rest = alloc(Token*);
  *rest = tok;
  Type *ty = declarator(rest, tok, dummy, scope);
  return is_FUNC(ty);
}

// program = (typedef | function-definition)*
Obj *parse(Token *tok) {
  Scope *scope = new_scope();
  Scope **scptr = alloc(Scope*);
  *scptr = scope;

  // Tracking global variables to ensure uniqueness of identifiers
  Obj **gblsptr = alloc(Obj*);
  *gblsptr = NULL;

  while (!is_EOF(tok)) {
    VarAttr *attr = new_attr();
    

    Token **rest = alloc(Token*);
    *rest = tok;
    Type *basety = declspec(rest, tok, attr, *scptr);
    tok = *rest;
    // Typedef
    if (attr->is_typedef) {
      tok = parse_typedef(tok, basety, *scptr);
     // Function
    } else if (is_function(tok, *scptr)) {
      tok = function(tok, basety, attr, scptr, gblsptr);
    }
  }

  return *gblsptr;
}


//-------------Testing-----------------------

void print_str_list(StringList *str) {
  if (str != NULL) {
    CharNode *cur = str->root;
    int i = 0;
    for (i ; i < get_len(str) ; i = i + 1) {
      printchar(cur->val);
      cur = cur->next;
    }
    printchar(cur->val);
  }
}

void print_tokens(Token *tlist) {
  Token *cur = tlist;
  while (cur != NULL) {
    print_str_list(name(cur));
    if (equals(name(cur), str_semicolon()) ||
        equals(name(cur), str_obracket())  ||
        equals(name(cur), str_cbracket())
        ) {
      println("");
    } else {
      print(" ");
    }
    cur = cur->next;
  }
}

void print_nodes(ASTNode *nlist, bool rep) {
  ASTNode *cur = nlist;
  if (cur == NULL) {
  } else if (rep) {
    while (cur != NULL) {
      print("rep: ");
      print_str_list(name(cur->tok));
      println("");
      
      print_nodes(cur->lhs, false);
      print_nodes(cur->rhs, false);
      print_nodes(cur->cond, false);
      print_nodes(cur->then, false);
      print_nodes(cur->els, false);
      print_nodes(cur->init, false);
      print_nodes(cur->inc, false);
      for (ASTNode *n = cur->body; n != NULL; n = n->next)
        print_nodes(n, false);
      for (ASTNode *n = cur->args; n != NULL; n = n->next)
        print_nodes(n, false);

      cur = cur->next;
    }
  } else {
    print_str_list(name(cur->tok));
    if (equals(name(cur->tok), str_semicolon())) {
      println("");
    } else {
      print(" ");
    }
    print_nodes(cur->lhs, false);
    print_nodes(cur->rhs, false);
    print_nodes(cur->cond, false);
    print_nodes(cur->then, false);
    print_nodes(cur->els, false);
    print_nodes(cur->init, false);
    print_nodes(cur->inc, false);
    for (ASTNode *n = cur->body; n != NULL; n = n->next)
      print_nodes(n, false);
    for (ASTNode *n = cur->args; n != NULL; n = n->next)
      print_nodes(n, false);
  }
}

Token *tok_ident(char c) {
  StringList *id_str = new_stringlist();
  add_char(id_str, c);
  return new_token(new_TK_IDENT(), id_str);
}

Token *nums(Token *tlist) {

  // 42 int lit
  StringList *n1 = new_stringlist();
  add_char(n1, '4');
  add_char(n1, '2');

  // 239 int lit
  StringList *n2 = new_stringlist();
  add_char(n2, '2');
  add_char(n2, '3');
  add_char(n2, '9');


  // 2.84 float
  StringList *f1 = new_stringlist();
  add_char(f1, '2');
  add_char(f1, '.');
  add_char(f1, '8');
  add_char(f1, '4');

  // 0.000
  StringList *f2 = new_stringlist();
  add_char(f2, '0');
  add_char(f2, '.');
  add_char(f2, '0');
  add_char(f2, '0');
  add_char(f2, '0');

  // int x, y;
  tlist->next = new_token(new_TK_KEYWORD(), str_int());
  tlist->next->next = tok_ident('x');
  tlist->next->next->next = new_token(new_TK_PUNCT(), str_comma());
  tlist->next->next->next->next = tok_ident('y');
  tlist->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  
  Token *stmt1 = tlist->next->next->next->next->next;

  // y = 42;
  stmt1->next = tok_ident('y');
  stmt1->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt1->next->next->next = new_token(new_TK_NUM(), n1);
  stmt1->next->next->next->ty = new_ty_int();
  stmt1->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt2 = stmt1->next->next->next->next;

  // x = y;
  stmt2->next = tok_ident('x');
  stmt2->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt2->next->next->next = tok_ident('y');
  stmt2->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt3 = stmt2->next->next->next->next;

  // x = 42 + 239 - y;
  stmt3->next = tok_ident('x');
  stmt3->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt3->next->next->next = new_token(new_TK_NUM(), n1);
  stmt3->next->next->next->ty = new_ty_int();
  stmt3->next->next->next->next = new_token(new_TK_PUNCT(), str_add());
  stmt3->next->next->next->next->next = new_token(new_TK_NUM(), n2);
  stmt3->next->next->next->next->next->ty = new_ty_int();
  stmt3->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_sub());
  stmt3->next->next->next->next->next->next->next = tok_ident('y');
  stmt3->next->next->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt4 = stmt3->next->next->next->next->next->next->next->next;

  // y = -x;
  stmt4->next = tok_ident('y');
  stmt4->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt4->next->next->next = new_token(new_TK_PUNCT(), str_sub());
  stmt4->next->next->next->next = tok_ident('x');
  stmt4->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt5 = stmt4->next->next->next->next->next;

  // y = x << 42;
  stmt5->next = tok_ident('y');
  stmt5->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt5->next->next->next = tok_ident('x');
  stmt5->next->next->next->next = new_token(new_TK_PUNCT(), str_bitshl());
  stmt5->next->next->next->next->next = new_token(new_TK_NUM(), n1);
  stmt5->next->next->next->next->next->ty = new_ty_int();
  stmt5->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt6 = stmt5->next->next->next->next->next->next;

  // y = x >> -239;
  stmt6->next = tok_ident('y');
  stmt6->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt6->next->next->next = tok_ident('x');
  stmt6->next->next->next->next = new_token(new_TK_PUNCT(), str_bitshr());
  stmt6->next->next->next->next->next = new_token(new_TK_PUNCT(), str_sub());
  stmt6->next->next->next->next->next->next = new_token(new_TK_NUM(), n2);
  stmt6->next->next->next->next->next->next->ty = new_ty_int();
  stmt6->next->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt7 = stmt6->next->next->next->next->next->next->next;

  
  // x = ~(y & x);
  stmt7->next = tok_ident('x');
  stmt7->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt7->next->next->next = new_token(new_TK_PUNCT(), str_bitnot());
  stmt7->next->next->next->next = new_token(new_TK_PUNCT(), str_oparen());
  stmt7->next->next->next->next->next = tok_ident('y');
  stmt7->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_bitand());
  stmt7->next->next->next->next->next->next->next = tok_ident('x');
  stmt7->next->next->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_cparen());
  stmt7->next->next->next->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt8 = stmt7->next->next->next->next->next->next->next->next->next;

  // float a, b, c;
  stmt8->next = new_token(new_TK_KEYWORD(), str_float());
  stmt8->next->next = tok_ident('a');
  stmt8->next->next->next = new_token(new_TK_PUNCT(), str_comma());
  stmt8->next->next->next->next = tok_ident('b');
  stmt8->next->next->next->next->next = new_token(new_TK_PUNCT(), str_comma());
  stmt8->next->next->next->next->next->next = tok_ident('c');
  stmt8->next->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt9 = stmt8->next->next->next->next->next->next->next;

  // b = 2.84 * 0.000;
  stmt9->next = tok_ident('b');
  stmt9->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt9->next->next->next = new_token(new_TK_NUM(), f1);
  stmt9->next->next->next->ty = new_ty_double();
  stmt9->next->next->next->next = new_token(new_TK_PUNCT(), str_mul());
  stmt9->next->next->next->next->next = new_token(new_TK_NUM(), f2);
  stmt9->next->next->next->next->next->ty = new_ty_double();
  stmt9->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt10 = stmt9->next->next->next->next->next->next;

  // c = 2.84 % 0.000 ;
  stmt10->next = tok_ident('c');
  stmt10->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt10->next->next->next = new_token(new_TK_NUM(), f1);
  stmt10->next->next->next->ty = new_ty_double();
  stmt10->next->next->next->next = new_token(new_TK_PUNCT(), str_mod());
  stmt10->next->next->next->next->next = new_token(new_TK_NUM(), f2);
  stmt10->next->next->next->next->next->ty = new_ty_double();
  stmt10->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt11 = stmt10->next->next->next->next->next->next;

  // a = b / c ;
  stmt11->next = tok_ident('a');
  stmt11->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt11->next->next->next = tok_ident('b');
  stmt11->next->next->next->next = new_token(new_TK_PUNCT(), str_div());
  stmt11->next->next->next->next->next = tok_ident('c');
  stmt11->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *end = stmt11->next->next->next->next->next->next;
  
  return end;
}

Token *bools(Token *tlist) {

  // bool b;
  tlist->next = new_token(new_TK_KEYWORD(), str_bool());
  tlist->next->next = tok_ident('b');
  tlist->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt1 = tlist->next->next->next;
 
  // bool c;
  stmt1->next = new_token(new_TK_KEYWORD(), str_bool());
  stmt1->next->next = tok_ident('c');
  stmt1->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt2 = stmt1->next->next->next;

  // bool d;
  stmt2->next = new_token(new_TK_KEYWORD(), str_bool());
  stmt2->next->next = tok_ident('d');
  stmt2->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt3 = stmt2->next->next->next;

  // b = c == d;
  stmt3->next = tok_ident('b');
  stmt3->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt3->next->next->next = tok_ident('c');
  stmt3->next->next->next->next = new_token(new_TK_PUNCT(), str_logeq());
  stmt3->next->next->next->next->next = tok_ident('d');
  stmt3->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt4 = stmt3->next->next->next->next->next->next;

  // b = c <= d;
  stmt4->next = tok_ident('b');
  stmt4->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt4->next->next->next = tok_ident('c');
  stmt4->next->next->next->next = new_token(new_TK_PUNCT(), str_le());
  stmt4->next->next->next->next->next = tok_ident('d');
  stmt4->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt5 = stmt4->next->next->next->next->next->next;

  // b = c < d;
  stmt5->next = tok_ident('b');
  stmt5->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt5->next->next->next = tok_ident('c');
  stmt5->next->next->next->next = new_token(new_TK_PUNCT(), str_lt());
  stmt5->next->next->next->next->next = tok_ident('d');
  stmt5->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt6 = stmt5->next->next->next->next->next->next;

  // b = c >= d;
  stmt6->next = tok_ident('b');
  stmt6->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt6->next->next->next = tok_ident('c');
  stmt6->next->next->next->next = new_token(new_TK_PUNCT(), str_ge());
  stmt6->next->next->next->next->next = tok_ident('d');
  stmt6->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt7 = stmt6->next->next->next->next->next->next;

  // b = c > d;
  stmt7->next = tok_ident('b');
  stmt7->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt7->next->next->next = tok_ident('c');
  stmt7->next->next->next->next = new_token(new_TK_PUNCT(), str_gt());
  stmt7->next->next->next->next->next = tok_ident('d');
  stmt7->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt8 = stmt7->next->next->next->next->next->next;

  // b = c && d;
  stmt8->next = tok_ident('b');
  stmt8->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt8->next->next->next = tok_ident('c');
  stmt8->next->next->next->next = new_token(new_TK_PUNCT(), str_logand());
  stmt8->next->next->next->next->next = tok_ident('d');
  stmt8->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt9 = stmt8->next->next->next->next->next->next;

  // b = !c;
  stmt9->next = tok_ident('b');
  stmt9->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt9->next->next->next = new_token(new_TK_PUNCT(), str_lognot());
  stmt9->next->next->next->next = tok_ident('c');
  stmt9->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt10 = stmt9->next->next->next->next->next;

  // b = c != d;
  stmt10->next = tok_ident('b');
  stmt10->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt10->next->next->next = tok_ident('c');
  stmt10->next->next->next->next = new_token(new_TK_PUNCT(), str_logneq());
  stmt10->next->next->next->next->next = tok_ident('d');
  stmt10->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *end = stmt10->next->next->next->next->next->next;

  return end;
}

Token *pointerss(Token *tlist) {

  // *&x;
  tlist->next = new_token(new_TK_PUNCT(), str_mul());
  tlist->next->next = new_token(new_TK_PUNCT(), str_bitand());
  tlist->next->next->next = tok_ident('x');
  tlist->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt1 = tlist->next->next->next->next;

  // int *l;
  stmt1->next = new_token(new_TK_KEYWORD(), str_int());
  stmt1->next->next = new_token(new_TK_PUNCT(), str_mul());
  stmt1->next->next->next = tok_ident('l');
  stmt1->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt2 = stmt1->next->next->next->next;

  //  *l = &x;
  stmt2->next = new_token(new_TK_PUNCT(), str_mul());
  stmt2->next->next = tok_ident('l');
  stmt2->next->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt2->next->next->next->next = new_token(new_TK_PUNCT(), str_bitand());
  stmt2->next->next->next->next->next = tok_ident('x');
  stmt2->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt3 = stmt2->next->next->next->next->next->next;

  // int **z;
  stmt3->next = new_token(new_TK_KEYWORD(), str_int());
  stmt3->next->next = new_token(new_TK_PUNCT(), str_mul());
  stmt3->next->next->next = new_token(new_TK_PUNCT(), str_mul());
  stmt3->next->next->next->next = tok_ident('z');
  stmt3->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt4 = stmt3->next->next->next->next->next;

  // **z = &y;
  stmt4->next = new_token(new_TK_PUNCT(), str_mul());
  stmt4->next->next = new_token(new_TK_PUNCT(), str_mul());
  stmt4->next->next->next = tok_ident('z');
  stmt4->next->next->next->next = new_token(new_TK_PUNCT(), str_eq());
  stmt4->next->next->next->next->next = new_token(new_TK_PUNCT(), str_bitand());
  stmt4->next->next->next->next->next->next = tok_ident('y');
  stmt4->next->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *stmt5 = stmt4->next->next->next->next->next->next->next;

  // **z;
  stmt5->next = new_token(new_TK_PUNCT(), str_mul());
  stmt5->next->next = new_token(new_TK_PUNCT(), str_mul());
  stmt5->next->next->next = tok_ident('z');
  stmt5->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
  Token *end = stmt5->next->next->next->next;

  return end;
}

Token *whiles(Token *tlist) {
    StringList *one = new_stringlist();
    add_char(one, '1');

    // while (p > 1) {
    tlist->next = new_token(new_TK_KEYWORD(), str_while());
    tlist->next->next = new_token(new_TK_PUNCT(), str_oparen());
    tlist->next->next->next = tok_ident('p');
    tlist->next->next->next->next = new_token(new_TK_PUNCT(), str_gt());
    tlist->next->next->next->next->next = new_token(new_TK_NUM(), one);
    tlist->next->next->next->next->next->ty = new_ty_int();
    tlist->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_cparen());
    tlist->next->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_obracket());
    Token *tmp = tlist->next->next->next->next->next->next->next;

    // bools
    tmp = bools(tmp);
    
    // }
    tmp->next = new_token(new_TK_PUNCT(), str_cbracket());
  return tmp->next;
}

Token *ifstmt(Token *tlist) {
  StringList *one = new_stringlist();
  add_char(one, '1');
  StringList *two = new_stringlist();
  add_char(two, '2');
  
  // if (p <= 1) {
  tlist->next = new_token(new_TK_KEYWORD(), str_if());
  tlist->next->next = new_token(new_TK_PUNCT(), str_oparen());
  tlist->next->next->next = tok_ident('p');
  tlist->next->next->next->next = new_token(new_TK_PUNCT(), str_le());
  tlist->next->next->next->next->next = new_token(new_TK_NUM(), one);
  tlist->next->next->next->next->next->ty = new_ty_int();
  tlist->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_cparen());
  tlist->next->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_obracket());
  Token *tmp = tlist->next->next->next->next->next->next->next;
  
    // while
    tmp = whiles(tmp);

    // return 1;
    tmp->next = new_token(new_TK_KEYWORD(), str_return());
    tmp->next->next = new_token(new_TK_NUM(), one);
    tmp->next->next->ty = new_ty_int();
    tmp->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
    Token *elsee = tmp->next->next->next;
  
  //} else {
    elsee->next = new_token(new_TK_PUNCT(), str_cbracket());
    elsee->next->next = new_token(new_TK_KEYWORD(), str_else());
    elsee->next->next->next = new_token(new_TK_PUNCT(), str_obracket());
    Token *ret2 = elsee->next->next->next;

    //return f(p-1) + f(p-2);
    ret2->next = new_token(new_TK_KEYWORD(), str_return());
    ret2->next->next = tok_ident('f');
    ret2->next->next->next = new_token(new_TK_PUNCT(), str_oparen());
    ret2->next->next->next->next = tok_ident('p');
    ret2->next->next->next->next->next = new_token(new_TK_PUNCT(), str_sub());
    ret2->next->next->next->next->next->next = new_token(new_TK_NUM(), one);
    ret2->next->next->next->next->next->next->ty = new_ty_int();
    ret2->next->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_cparen());
    Token *retp = ret2->next->next->next->next->next->next->next;

    retp->next = new_token(new_TK_PUNCT(), str_add());
    retp->next->next = tok_ident('f');
    retp->next->next->next = new_token(new_TK_PUNCT(), str_oparen());
    retp->next->next->next->next = tok_ident('p');
    retp->next->next->next->next->next = new_token(new_TK_PUNCT(), str_sub());
    retp->next->next->next->next->next->next = new_token(new_TK_NUM(), two);
    retp->next->next->next->next->next->next->ty = new_ty_int();
    retp->next->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_cparen());
    retp->next->next->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());
    Token *end = retp->next->next->next->next->next->next->next->next;

  //}
  end->next = new_token(new_TK_PUNCT(), str_cbracket());
  return end->next;
}


Token *functions(Token *tlist) {
  // int f(int p) {
  tlist->next = new_token(new_TK_KEYWORD(), str_int());
  tlist->next->next = tok_ident('f');
  tlist->next->next->next = new_token(new_TK_PUNCT(), str_oparen());
  tlist->next->next->next->next = new_token(new_TK_KEYWORD(), str_int());
  tlist->next->next->next->next->next = tok_ident('p');
  tlist->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_cparen());
  tlist->next->next->next->next->next->next->next = new_token(new_TK_PUNCT(), str_obracket()); 
  Token *tmp = tlist->next->next->next->next->next->next->next;
  
  // nums
  tmp = nums(tmp);

  // pointers
  tmp = pointerss(tmp);

  // if
  tmp = ifstmt(tmp);

  // }
  tmp->next = new_token(new_TK_PUNCT(), str_cbracket());
  return tmp->next;
}

int main() {
  // typedef int t;
  Token *start = new_token(new_TK_KEYWORD(), str_typedef());
  start->next = new_token(new_TK_KEYWORD(), str_int());
  start->next->next = tok_ident('t');
  start->next->next->next = new_token(new_TK_PUNCT(), str_semicolon());

  Token *tmp = functions(start->next->next->next);
  
  
  // EOF
  tmp->next = new_token(new_TK_EOF(), NULL);

  print_tokens(start);
  Obj *globals = parse(start);
  
  // print globals;
  while (globals != NULL) {
    if (globals->is_function) {
      print("printing nodes for function ");
      print_str_list(globals->name);
      print(" with params: ");
      Obj *params = globals->params;
      while (params != NULL) {
        if (params->ty == NULL)
          error("param without a type");
        print_str_list(params->name);
        print(" ");
        params = params->next;
      }
      println("");
      print_nodes(globals->body, true);
    }
    globals = globals->next;
  }
  return 0;
}